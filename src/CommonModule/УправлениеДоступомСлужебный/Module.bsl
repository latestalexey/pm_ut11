////////////////////////////////////////////////////////////////////////////////
// Подсистема "Управление доступом".
// 
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЙ ПРОГРАММНЫЙ ИНТЕРФЕЙС

// Устанавливает параметры сеанса по текущим настройкам констант и
// настройкам групп доступа пользователей.
//  Вызывается ПриНачалеРаботыСистемы.
//
Процедура УстановкаПараметровСеанса(ИмяПараметра, УстановленныеПараметры) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если НЕ Константы.ОграничиватьДоступНаУровнеЗаписей.Получить() Тогда
		// Для корректной работы препроцессора в ограничениях доступа, требуется инициализации всех
		// параметров сеанса, которые могут быть востребованы в работе препроцессора.
		Если ИмяПараметра = "ВидыДоступаЕдинственныеДляТипаЗначенияДоступа" ИЛИ
		     ИмяПараметра = "ВидыДоступаБезГруппЗначенияДоступа" Тогда
			ПараметрыСеанса[ИмяПараметра] = Новый ФиксированныйМассив(Новый Массив);
		Иначе
			ПараметрыСеанса[ИмяПараметра] = "";
		КонецЕсли;
		УстановленныеПараметры.Добавить(ИмяПараметра);
		Возврат;
	КонецЕсли;
	
	// Следующие виды доступа не самостоятельные,
	// поэтому не учитываются при расчете необходимости ограничения в целом.
	// В стандартных шаблонах проверка по этим видам доступа всегда выполняется,
	// а в препроцессоре проверка использования не выполнятся.
	ПараметрыСеанса.ОграничиватьДоступПоВидуУсловие = "";
	ПараметрыСеанса.ОграничиватьДоступПоВидуОбъект  = "";
	УстановленныеПараметры.Добавить("ОграничиватьДоступПоВидуУсловие");
	УстановленныеПараметры.Добавить("ОграничиватьДоступПоВидуОбъект");
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ТекущийПользователь", Пользователи.АвторизованныйПользователь());
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ВидыДоступаПрофилейГруппДоступа.ВидДоступа
	|ИЗ
	|	Справочник.ПрофилиГруппДоступа.ВидыДоступа КАК ВидыДоступаПрофилейГруппДоступа
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ГруппыДоступа КАК ГруппыДоступа
	|		ПО (ГруппыДоступа.Профиль = ВидыДоступаПрофилейГруппДоступа.Ссылка)
	|			И (НЕ ВидыДоступаПрофилейГруппДоступа.Ссылка.ПометкаУдаления)
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|		ПО (ГруппыДоступа.Ссылка = ГруппыДоступаПользователи.Ссылка)
	|			И (НЕ ГруппыДоступа.ПометкаУдаления)
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|		ПО (СоставыГруппПользователей.Пользователь = &ТекущийПользователь)
	|			И (СоставыГруппПользователей.ГруппаПользователей = ГруппыДоступаПользователи.Пользователь)";
	ОграничиваемыеВидыДоступа = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("ВидДоступа");
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ВидыДоступа.Ссылка КАК ВидДоступа
	|ИЗ
	|	ПланВидовХарактеристик.ВидыДоступа КАК ВидыДоступа
	|ГДЕ
	|	ВидыДоступа.Предопределенный");
	Выборка = Запрос.Выполнить().Выбрать();
	
	КаждыйВидЕдинственный = Истина;
	КаждыйВидБезГрупп     = Истина;
	
	ВидыДоступаБезОграничения                     = Новый Массив;
	ВидыДоступаЕдинственныеДляТипаЗначенияДоступа = Новый Массив;
	ВидыДоступаБезГруппЗначенияДоступа            = Новый Массив;
	ВидыДоступаЧерезПраваПоЗначениямДоступа       = Новый Массив;
	
	Пока Выборка.Следующий() Цикл
		
		СвойстваВидаДоступа = СвойстваВидаДоступа(Выборка.ВидДоступа);
		
		Если  СвойстваВидаДоступа.ВидДоступаИспользуетсяВсегда Тогда
			// Такие виды доступа не самостоятельные, поэтому не учитываются при расчете
			// необходимости ограничения в целом.
			// В стандартных шаблонах проверка по этим видам доступа всегда выполняется,
			// а в препроцессоре проверка использования не выполнятся.
			ОписаниеВидаДоступа = "";
			
		ИначеЕсли НЕ ВидДоступаИспользуется(Выборка.ВидДоступа) Тогда
			ОписаниеВидаДоступа = "";
			ВидыДоступаБезОграничения.Добавить(Выборка.ВидДоступа);
			
		ИначеЕсли ОграничиваемыеВидыДоступа.Найти(Выборка.ВидДоступа) = Неопределено Тогда
			ОписаниеВидаДоступа = "";
			ВидыДоступаБезОграничения.Добавить(Выборка.ВидДоступа);
			
		ИначеЕсли СвойстваВидаДоступа.ВидДоступаЧерезПраваПоЗначениямДоступа Тогда
			ОписаниеВидаДоступа = "ЧерезПраваПоЗначениямДоступа";
			ВидыДоступаЧерезПраваПоЗначениямДоступа.Добавить(Выборка.ВидДоступа);
		Иначе
			Если СвойстваВидаДоступа.ВидДоступаЕдинственныйДляТипаЗначенияДоступа Тогда
				ОписаниеВидаДоступа   = "ЕдинственныйВид,  ";
				ВидыДоступаЕдинственныеДляТипаЗначенияДоступа.Добавить(Выборка.ВидДоступа);
			Иначе
				ОписаниеВидаДоступа   = "ОдинИзМногихВидов,";
				КаждыйВидЕдинственный = Ложь;
			КонецЕсли;
			Если СвойстваВидаДоступа.ВидДоступаБезГруппЗначенияДоступа Тогда
				ОписаниеГрупп = "БезГрупп";
				ВидыДоступаБезГруппЗначенияДоступа.Добавить(Выборка.ВидДоступа);
			Иначе
				ОписаниеГрупп = ?(СвойстваВидаДоступа.ВидДоступаСОднойГруппойЗначенияДоступа, "ОднаГруппа", "МножествоГрупп");
				КаждыйВидБезГрупп = Ложь;
			КонецЕсли;
			ОписаниеВидаДоступа = ОписаниеВидаДоступа + ОписаниеГрупп;
		КонецЕсли;
		ИмяВидаДоступа = ПланыВидовХарактеристик.ВидыДоступа.ПолучитьИмяПредопределенного(Выборка.ВидДоступа);
		ПараметрыСеанса["ОграничиватьДоступПоВиду" + ИмяВидаДоступа] = ОписаниеВидаДоступа;
		УстановленныеПараметры.Добавить("ОграничиватьДоступПоВиду" + ИмяВидаДоступа);
	КонецЦикла;
	
	ПараметрыСеанса.ВидыДоступаБезОграничения = Новый ФиксированныйМассив(ВидыДоступаБезОграничения);
	УстановленныеПараметры.Добавить("ВидыДоступаБезОграничения");
	
	ПараметрыСеанса.ВидыДоступаЕдинственныеДляТипаЗначенияДоступа = Новый ФиксированныйМассив(ВидыДоступаЕдинственныеДляТипаЗначенияДоступа);
	УстановленныеПараметры.Добавить("ВидыДоступаЕдинственныеДляТипаЗначенияДоступа");
	
	ПараметрыСеанса.ВидыДоступаБезГруппЗначенияДоступа = Новый ФиксированныйМассив(ВидыДоступаБезГруппЗначенияДоступа);
	УстановленныеПараметры.Добавить("ВидыДоступаБезГруппЗначенияДоступа");
	
	ПараметрыСеанса.ВидыДоступаЧерезПраваПоЗначениямДоступа = ?(ВидыДоступаЧерезПраваПоЗначениямДоступа.Количество() = 0,
	                                                            "",
	                                                            Новый ФиксированныйМассив(ВидыДоступаЧерезПраваПоЗначениямДоступа));
	УстановленныеПараметры.Добавить("ВидыДоступаЧерезПраваПоЗначениямДоступа");
	
	Если КаждыйВидЕдинственный И КаждыйВидБезГрупп Тогда
		ПараметрыСеанса.ОграничиватьДоступПоВиду = "КаждыйВидЕдинственный, КаждыйВидБезГрупп";
	ИначеЕсли КаждыйВидЕдинственный Тогда
		ПараметрыСеанса.ОграничиватьДоступПоВиду = "КаждыйВидЕдинственный";
	ИначеЕсли КаждыйВидБезГрупп Тогда
		ПараметрыСеанса.ОграничиватьДоступПоВиду = "КаждыйВидБезГрупп";
	Иначе
		ПараметрыСеанса.ОграничиватьДоступПоВиду = "Да";
	КонецЕсли;
	УстановленныеПараметры.Добавить("ОграничиватьДоступПоВиду");
	
КонецПроцедуры

// Добавляет в список Обработчики процедуры-обработчики обновления,
// необходимые данной подсистеме.
//
// Параметры:
//   Обработчики - ТаблицаЗначений - см. описание функции НоваяТаблицаОбработчиковОбновления
//                                   общего модуля ОбновлениеИнформационнойБазы.
// 
Процедура ЗарегистрироватьОбработчикиОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.Приоритет = 1;
	Обработчик.Версия = "*";
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ОбновитьПараметрыОграниченияДоступа";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "*";
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.2.8";
	Обработчик.Процедура = "РегистрыСведений.УдалитьПраваПоЗначениямДоступа.ПереместитьДанныеВНовыйРегистр";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.2.8";
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ПреобразоватьИменаРолейВИдентификаторы";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.2.8";
	Обработчик.Процедура = "РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.2.16";
	Обработчик.Процедура = "РегистрыСведений.ТаблицыГруппДоступа.ОбновитьДанныеРегистра";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.2.16";
	Обработчик.Процедура = "УправлениеДоступом.ОбновитьРолиПользователей";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.2.23";
	Обработчик.Процедура = "РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей";
	
КонецПроцедуры

// Переопределяет стандартное поведение при получении данных в распределенной ИБ.
// Игнорирует получение данных подсистемы из автономного рабочего места в сервис.
// Выполняет отправку данных подсистемы в автономное рабочее место для их синхронизации с сервисом.
//
Процедура ПриПолученииДанных(ЭлементДанных, ПолучениеЭлемента, ОтправкаНазад, ОтПодчиненного) Экспорт
	
	Если ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать Тогда
		
		// Стандартная обработка не переопределяется.
		
	ИначеЕсли ТипЗнч(ЭлементДанных) = Тип("КонстантаМенеджерЗначения.ПараметрыОграниченияДоступа")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("ПланВидовХарактеристикОбъект.ВидыДоступа")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ЗависимостиПравДоступа")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ПраваРолей") Тогда
		
		// Эти данные не участвуют в обмене данными (как метаданные).
		ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать;
	
	ИначеЕсли ТипЗнч(ЭлементДанных) = Тип("КонстантаМенеджерЗначения.ОграничиватьДоступНаУровнеЗаписей")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ГруппыДоступа")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ПрофилиГруппДоступа")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ГруппыЗначенийДоступа")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ЗначенияГруппДоступа")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.НаборыЗначенийДоступа")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ПраваПоЗначениямДоступа")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.УдалитьПраваПоЗначениямДоступа")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ТаблицыГруппДоступа") Тогда
		
		Если ОтПодчиненного И ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
			
			// Получение данных из автономного рабочего места пропускается, а для соответствия
			// данных в узлах, текущие данные отправляются обратно в автономное рабочее место.
			ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать;
			ОтправкаНазад = Истина;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Доопереопределяет поведение после получения данных в распределенной ИБ.
Процедура ПослеПолученияДанных(Отправитель, Отказ, ОтПодчиненного) Экспорт
	
	УправлениеДоступом.ОбновитьРолиПользователей();
	
КонецПроцедуры

// Заполняет структуру параметров, необходимых для работы клиентского кода
// конфигурации. 
//
// Параметры:
//   Параметры   - Структура - структура параметров.
//
Процедура ДобавитьПараметрыРаботыКлиента(Параметры) Экспорт
	
	Параметры.Вставить("УпрощенныйИнтерфейсНастройкиПравДоступа", 
		УправлениеДоступомПереопределяемый.УпрощенныйИнтерфейсНастройкиПравДоступа());
	
КонецПроцедуры

// Обновляет состав пользователей указанных групп исполнителей.
// 
// Требуется вызывать при изменении состава пользователей у групп исполнителей,
// например, у групп исполнителей задач.
//
// В качестве значений параметра передается группы исполнителей, состав которых изменился.
//
// Параметры:
//  ГруппыИсполнителей - Например, СправочникСсылка.ГруппыИсполнителейЗадач.
//                     - Массив значений указанных выше типов.
//                     - Неопределено - без отбора.
//
Процедура ОбновитьПользователейГруппИсполнителей(ГруппыИсполнителей = Неопределено) Экспорт
	
	Если ТипЗнч(ГруппыИсполнителей) = Тип("Массив") И ГруппыИсполнителей.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Параметры = Новый Структура;
	Параметры.Вставить("ГруппыИсполнителей", ГруппыИсполнителей);
	
	РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей(Параметры);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

////////////////////////////////////////////////////////////////////////////////
// Обработчики подписок на события

// Обработчик подписки ОбновитьГруппыЗначенийДоступа на событие ПередЗаписью
// вызывает метод записи групп значений доступа в
// РегистрСведений.ГруппыЗначенийДоступа, для требуемых объектов метаданных.
//
Процедура ОбновитьГруппыЗначенийДоступа(Знач Объект, Отказ) Экспорт
	
	Если Объект.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(Объект) = Тип("ПланВидовХарактеристикОбъект.ВидыДоступа") Тогда
		Возврат;
	КонецЕсли;
	
	Параметры = УправлениеДоступомСлужебныйПовтИсп.Параметры();
	ЗначенияДоступаСГруппами         = Параметры.СвойстваВидовДоступа.ЗначенияДоступаСГруппами;
	ВозможныеПраваПоЗначениямДоступа = Параметры.ВозможныеПраваПоЗначениямДоступа;
	
	Если ЗначенияДоступаСГруппами.ПоТипам.Получить(ТипЗнч(Объект)) <> Неопределено Тогда
		РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппыЗначенийДоступа(Объект);
	КонецЕсли;
	
	Если ВозможныеПраваПоЗначениямДоступа.ПоТипам.Получить(ТипЗнч(Объект)) <> Неопределено Тогда
		РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьИерархиюВладельцевНастроекПравОбъектов(Объект);
	КонецЕсли;
	
КонецПроцедуры

// Обработчик подписки ЗаписатьНаборыЗначенийДоступа на событие ПриЗаписи
// вызывает метод записи значений доступа объекта в РегистрСведений.НаборыЗначенийДоступа.
//  Возможен случай использования подсистемы "УправлениеДоступом", когда
// указанной подписки не существует, если наборы значений доступа не применяются.
//
Процедура ЗаписатьНаборыЗначенийДоступаПриЗаписи(Знач Объект, Отказ) Экспорт

	Если Объект.ОбменДанными.Загрузка
	   И НЕ Объект.ДополнительныеСвойства.Свойство("ЗаписатьНаборыЗначенийДоступа") Тогда
		
		Возврат;
	КонецЕсли;
	
	ЗаписатьНаборыЗначенийДоступа(Объект);
	
КонецПроцедуры

// Обработчик подписки ЗаписатьЗависимыеНаборыЗначенийДоступа события ПриЗаписи
// вызывает перезапись зависимых наборов значений доступа в регистре сведений НаборыЗначенийДоступа.
//
//  Возможен случай использования подсистемы "УправлениеДоступом", когда
// указанной подписки не существует, если зависимые наборы значений доступа не применяются.
//
Процедура ЗаписатьЗависимыеНаборыЗначенийДоступаПриЗаписи(Знач Объект, Отказ) Экспорт
	
	Если Объект.ОбменДанными.Загрузка
	   И НЕ Объект.ДополнительныеСвойства.Свойство("ЗаписатьЗависимыеНаборыЗначенийДоступа") Тогда
		
		Возврат;
	КонецЕсли;
	
	ЗаписатьЗависимыеНаборыЗначенийДоступа(Объект);
	
КонецПроцедуры

// Обработчик регламентного задания ЗаполнениеДанныхДляОграниченияДоступа.
Процедура ЗаполнениеДанныхДляОграниченияДоступаОбработчикЗадания() Экспорт
	
	ЗаполнениеДанныхДляОграниченияДоступа();
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики регламентных заданий

// Выполняет последовательное заполнение и обновление данных, необходимых для работы
// подсистемы УправленияДоступом в режиме ограничения доступа на уровне записей.
// 
//  При включенном режиме ограничения доступа на уровне записей заполняет наборы
// значений доступа. Заполнение выполняется частями при каждом запуске, пока все
// наборы значений доступа не будут заполнены.
//  При отключении режима ограничения доступа на уровне записей наборы значений доступа
// (заполненные ранее) удаляются при перезаписи объектов, а не все сразу.
//  Независимо от режима ограничения доступа на уровне записей обновляет вторичные
// данные: группы значений доступа и дополнительные поля в существующих наборах значений доступа.
//  После завершения всех обновлений и заполнений отключает использование регламентного
// задания.
//
//  Сведения о состоянии работы записываются в журнал регистрации.
//
//  Возможно вызывать программно, например, при обновлении информационной базы.
// Также для целей обновления есть форма Справочник.ГруппыДоступа.ОбновлениеДанныхОграниченияДоступа,
// с помощью которой можно сделать интерактивное обновление данных ограничения доступа
// при обновлении информационной базы.
//
Процедура ЗаполнениеДанныхДляОграниченияДоступа(КоличествоДанных = 0) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Параметры = УправлениеДоступомСлужебныйПовтИсп.Параметры();
	ЗначенияДоступаСГруппами         = Параметры.СвойстваВидовДоступа.ЗначенияДоступаСГруппами;
	ВидыДоступаЗначенийДоступа       = Параметры.СвойстваВидовДоступа.ВидыДоступаЗначенийДоступа;
	ВозможныеПраваПоЗначениямДоступа = Параметры.ВозможныеПраваПоЗначениямДоступа;
	
	Если УправлениеДоступом.ОграничиватьДоступНаУровнеЗаписей() Тогда
		
		РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей();
		
		// Заполнение РегистрСведений.ГруппыЗначенийДоступа.
		Для каждого Тип Из Метаданные.ПодпискиНаСобытия.ОбновитьГруппыЗначенийДоступа.Источник.Типы() Цикл
			
			Если Тип = Тип("ПланВидовХарактеристикОбъект.ВидыДоступа") Тогда
				Продолжить;
			КонецЕсли;
			
			ВидыДоступа = ВидыДоступаЗначенийДоступа.ПоТипам[Тип];
			Если ВидыДоступа.Количество() = 1 И
			     ( ВидыДоступа[0] = ПланыВидовХарактеристик.ВидыДоступа.Пользователи ИЛИ 
			       ВидыДоступа[0] = ПланыВидовХарактеристик.ВидыДоступа.ВнешниеПользователи ) Тогда
				Продолжить;
			КонецЕсли;
			
			Если КоличествоДанных < 1000 И Тип <> Тип("Строка") Тогда
				
				Запрос = Новый Запрос;
				Запрос.Текст =
				"ВЫБРАТЬ РАЗЛИЧНЫЕ ПЕРВЫЕ 1000
				|	Таблица.Ссылка
				|ИЗ
				|	ПодставляемаяТаблица КАК Таблица
				|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК РегистрСведенийГруппыЗначенийДоступа
				|		ПО Таблица.Ссылка = РегистрСведенийГруппыЗначенийДоступа.ЗначениеДоступа
				|ГДЕ
				|	РегистрСведенийГруппыЗначенийДоступа.ЗначениеДоступа ЕСТЬ NULL ";
				
				Запрос.Текст = СтрЗаменить(
					Запрос.Текст, "ПодставляемаяТаблица", Метаданные.НайтиПоТипу(Тип).ПолноеИмя() );
				
				Выгрузка = Запрос.Выполнить().Выгрузить();
				КоличествоДанных = КоличествоДанных + Выгрузка.Количество();
				
				Для каждого СтрокаТЧ Из Выгрузка Цикл
					
					Если ЗначенияДоступаСГруппами.ПоТипам.Получить(Тип) <> Неопределено Тогда
						РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппыЗначенийДоступа(СтрокаТЧ.Ссылка);
						
					ИначеЕсли ВозможныеПраваПоЗначениямДоступа.ПоТипам.Получить(Тип) <> Неопределено Тогда
						РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьИерархиюВладельцевНастроекПравОбъектов(СтрокаТЧ.Ссылка);
					КонецЕсли;
				КонецЦикла;
				
			КонецЕсли;
		КонецЦикла;
		
		Если КоличествоДанных < 1000 Тогда
			
			// Заполнение РегистрСведений.НаборыЗначенийДоступа.
			Для каждого Тип Из Метаданные.ПодпискиНаСобытия.ЗаписатьНаборыЗначенийДоступа.Источник.Типы() Цикл
				
				Если Тип = Тип("ПланВидовХарактеристикОбъект.ВидыДоступа") Тогда
					Продолжить;
				КонецЕсли;
				
				ЗаполнитьТабличнуюЧасть = Метаданные.НайтиПоТипу(Тип).ТабличныеЧасти.Найти("НаборыЗначенийДоступа") <> Неопределено;
				
				Если КоличествоДанных < 1000 И Тип <> Тип("Строка") Тогда
				
					Запрос = Новый Запрос(СтрЗаменить(
					"ВЫБРАТЬ РАЗЛИЧНЫЕ ПЕРВЫЕ 1000
					|	Таблица.Ссылка
					|ИЗ
					|	ПодставляемаяТаблица КАК Таблица
					|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.НаборыЗначенийДоступа КАК РегистрСведенийНаборыЗначенийДоступа
					|		ПО Таблица.Ссылка = РегистрСведенийНаборыЗначенийДоступа.Объект
					|ГДЕ
					|	РегистрСведенийНаборыЗначенийДоступа.Объект ЕСТЬ NULL ", "ПодставляемаяТаблица", Метаданные.НайтиПоТипу(Тип).ПолноеИмя()));
					Выгрузка = Запрос.Выполнить().Выгрузить();
					КоличествоДанных = КоличествоДанных + Выгрузка.Количество();
					
					Для каждого СтрокаТЧ Из Выгрузка Цикл
						Если ЗаполнитьТабличнуюЧасть Тогда
							// Запись наборов табличной части и наборов регистра (без зависимых наборов).
							Объект = СтрокаТЧ.Ссылка.ПолучитьОбъект();
							Объект.ОбменДанными.Загрузка = Истина;
							Объект.ДополнительныеСвойства.Вставить("ЗаписатьНаборыЗначенийДоступа");
							Объект.Записать();
						Иначе
							// Запись только наборов регистра (без зависимых наборов).
							ЗаписатьНаборыЗначенийДоступа(СтрокаТЧ.Ссылка);
						КонецЕсли;
					КонецЦикла;
					
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
	КонецЕсли;
	
	Если КоличествоДанных < 1000 Тогда
		// Обновление вторичных данных в наборах значений доступа: свойств видов доступа , и других.
	
		Запрос = Новый Запрос(
		"ВЫБРАТЬ
		|	СвойстваВидовДоступа.ВидДоступа,
		|	СвойстваВидовДоступа.ВидДоступаБезГруппЗначенияДоступа,
		|	СвойстваВидовДоступа.ВидДоступаЕдинственныйДляТипаЗначенияДоступа,
		|	СвойстваВидовДоступа.ВидДоступаЧерезПраваПоЗначениямДоступа
		|ПОМЕСТИТЬ ТаблицаСвойств
		|ИЗ
		|	&СвойстваВидовДоступа КАК СвойстваВидовДоступа
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ РАЗЛИЧНЫЕ ПЕРВЫЕ 1000
		|	НаборыЗначенийДоступа.Объект,
		|	НаборыЗначенийДоступа.НомерНабора,
		|	НаборыЗначенийДоступа.ВидДоступа,
		|	НаборыЗначенийДоступа.ЗначениеДоступа,
		|	НаборыЗначенийДоступа.Чтение,
		|	НаборыЗначенийДоступа.Добавление,
		|	НаборыЗначенийДоступа.Изменение,
		|	НаборыЗначенийДоступа.Удаление,
		|	ЕСТЬNULL(СвойстваВидовДоступа.ВидДоступаБезГруппЗначенияДоступа, ЛОЖЬ) КАК ВидДоступаБезГруппЗначенияДоступа,
		|	ЕСТЬNULL(СвойстваВидовДоступа.ВидДоступаЕдинственныйДляТипаЗначенияДоступа, ЛОЖЬ) КАК ВидДоступаЕдинственныйДляТипаЗначенияДоступа,
		|	ЕСТЬNULL(СвойстваВидовДоступа.ВидДоступаЧерезПраваПоЗначениямДоступа, ЛОЖЬ) КАК ВидДоступаЧерезПраваПоЗначениямДоступа,
		|	ВЫБОР
		|		КОГДА НаборыЗначенийДоступа.Чтение
		|			ТОГДА ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыДоступа.ПравоЧтения)
		|		ИНАЧЕ ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыДоступа.ПустаяСсылка)
		|	КОНЕЦ КАК ВидДоступаПравоЧтения,
		|	ВЫБОР
		|		КОГДА НаборыЗначенийДоступа.Добавление
		|			ТОГДА ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыДоступа.ПравоДобавления)
		|		ИНАЧЕ ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыДоступа.ПустаяСсылка)
		|	КОНЕЦ КАК ВидДоступаПравоДобавления,
		|	ВЫБОР
		|		КОГДА НаборыЗначенийДоступа.Изменение
		|			ТОГДА ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыДоступа.ПравоИзменения)
		|		ИНАЧЕ ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыДоступа.ПустаяСсылка)
		|	КОНЕЦ КАК ВидДоступаПравоИзменения,
		|	НаборыЗначенийДоступа.ТипОбъекта,
		|	ЕСТЬNULL(Идентификаторы.ЗначениеПустойСсылки, НЕОПРЕДЕЛЕНО) КАК ТипЗначенияДоступа
		|ИЗ
		|	РегистрСведений.НаборыЗначенийДоступа КАК НаборыЗначенийДоступа
		|		ЛЕВОЕ СОЕДИНЕНИЕ ТаблицаСвойств КАК СвойстваВидовДоступа
		|		ПО НаборыЗначенийДоступа.ВидДоступа = СвойстваВидовДоступа.ВидДоступа
		|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ИдентификаторыОбъектовМетаданных КАК Идентификаторы
		|		ПО (ТИПЗНАЧЕНИЯ(НаборыЗначенийДоступа.ЗначениеДоступа) = ТИПЗНАЧЕНИЯ(Идентификаторы.ЗначениеПустойСсылки))
		|			И (НаборыЗначенийДоступа.ВидДоступа В (ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыДоступа.ПравоЧтения), ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыДоступа.ПравоДобавления), ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыДоступа.ПравоИзменения)))
		|ГДЕ
		|	(НЕ(НаборыЗначенийДоступа.ВидДоступаБезГруппЗначенияДоступа = ЕСТЬNULL(СвойстваВидовДоступа.ВидДоступаБезГруппЗначенияДоступа, ЛОЖЬ)
		|				И НаборыЗначенийДоступа.ВидДоступаЕдинственныйДляТипаЗначенияДоступа = ЕСТЬNULL(СвойстваВидовДоступа.ВидДоступаЕдинственныйДляТипаЗначенияДоступа, ЛОЖЬ)
		|				И НаборыЗначенийДоступа.ВидДоступаЧерезПраваПоЗначениямДоступа = ЕСТЬNULL(СвойстваВидовДоступа.ВидДоступаЧерезПраваПоЗначениямДоступа, ЛОЖЬ)
		|				И НаборыЗначенийДоступа.ТипЗначенияДоступа = ЕСТЬNULL(Идентификаторы.ЗначениеПустойСсылки, НЕОПРЕДЕЛЕНО)
		|				И НаборыЗначенийДоступа.ВидДоступаПравоЧтения = ВЫБОР
		|					КОГДА НаборыЗначенийДоступа.Чтение
		|						ТОГДА ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыДоступа.ПравоЧтения)
		|					ИНАЧЕ ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыДоступа.ПустаяСсылка)
		|				КОНЕЦ
		|				И НаборыЗначенийДоступа.ВидДоступаПравоДобавления = ВЫБОР
		|					КОГДА НаборыЗначенийДоступа.Добавление
		|						ТОГДА ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыДоступа.ПравоДобавления)
		|					ИНАЧЕ ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыДоступа.ПустаяСсылка)
		|				КОНЕЦ
		|				И НаборыЗначенийДоступа.ВидДоступаПравоИзменения = ВЫБОР
		|					КОГДА НаборыЗначенийДоступа.Изменение
		|						ТОГДА ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыДоступа.ПравоИзменения)
		|					ИНАЧЕ ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыДоступа.ПустаяСсылка)
		|				КОНЕЦ))");
		Запрос.УстановитьПараметр("СвойстваВидовДоступа", СвойстваВидаДоступа());
		Выгрузка = Запрос.Выполнить().Выгрузить();
		КоличествоДанных = КоличествоДанных + Выгрузка.Количество();
		
		Для каждого СтрокаТЧ Из Выгрузка Цикл
			МенеджерЗаписи = РегистрыСведений.НаборыЗначенийДоступа.СоздатьМенеджерЗаписи();
			ЗаполнитьЗначенияСвойств(
				МенеджерЗаписи,
				СтрокаТЧ,
				"Объект,
				|НомерНабора,
				|ВидДоступа,
				|ЗначениеДоступа,
				|Чтение,
				|Добавление,
				|Изменение,
				|Удаление,
				|ВидДоступаБезГруппЗначенияДоступа,
				|ВидДоступаЕдинственныйДляТипаЗначенияДоступа,
				|ВидДоступаЧерезПраваПоЗначениямДоступа,
				|ВидДоступаПравоЧтения,
				|ВидДоступаПравоДобавления,
				|ВидДоступаПравоИзменения,
				|ТипОбъекта,
				|ТипЗначенияДоступа");
			МенеджерЗаписи.Записать();
		КонецЦикла;
	КонецЕсли;
	
	Если КоличествоДанных < 1000 Тогда
		// Обновление вторичных данных в наборах значений доступа: ТипОбъекта
	
		Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 1000
		|	ТипыОбъектов.Объект
		|ИЗ
		|	(ВЫБРАТЬ
		|		НаборыЗначенийДоступа.Объект КАК Объект,
		|		ВЫБОР
		|			КОГДА НаборыЗначенийДоступа.ТипОбъекта <> НЕОПРЕДЕЛЕНО
		|				ТОГДА 1
		|			ИНАЧЕ 0
		|		КОНЕЦ КАК ТипЗадан,
		|		ВЫБОР
		|			КОГДА НаборыЗначенийДоступа.ТипОбъекта <> НЕОПРЕДЕЛЕНО
		|					И НаборыЗначенийДоступа.ТипОбъекта <> Идентификаторы.ЗначениеПустойСсылки
		|				ТОГДА 1
		|			ИНАЧЕ 0
		|		КОНЕЦ КАК НеверныйТип
		|	ИЗ
		|		РегистрСведений.НаборыЗначенийДоступа КАК НаборыЗначенийДоступа
		|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ИдентификаторыОбъектовМетаданных КАК Идентификаторы
		|			ПО (ТИПЗНАЧЕНИЯ(НаборыЗначенийДоступа.Объект) = ТИПЗНАЧЕНИЯ(Идентификаторы.ЗначениеПустойСсылки))) КАК ТипыОбъектов
		|
		|СГРУППИРОВАТЬ ПО
		|	ТипыОбъектов.Объект
		|
		|ИМЕЮЩИЕ
		|	(СУММА(ТипыОбъектов.ТипЗадан) <> 1
		|		ИЛИ СУММА(ТипыОбъектов.НеверныйТип) <> 0)");
		Выгрузка = Запрос.Выполнить().Выгрузить();
		КоличествоДанных = КоличествоДанных + Выгрузка.Количество();
		
		НаборЗаписей = РегистрыСведений.НаборыЗначенийДоступа.СоздатьНаборЗаписей();
		Для каждого СтрокаТЧ Из Выгрузка Цикл
		
			НаборЗаписей.Отбор.Объект.Установить(СтрокаТЧ.Объект);
			НаборЗаписей.Прочитать();
			ПерваяЗапись = Истина;
			
			Для каждого Запись Из НаборЗаписей Цикл
				
				Если ПерваяЗапись Тогда
					ТипыОбъекта = Новый Массив;
					ТипыОбъекта.Добавить(ТипЗнч(Запись.Объект));
					ОписаниеТипаОбъекта = Новый ОписаниеТипов(ТипыОбъекта);
					
					Запись.ТипОбъекта = ОписаниеТипаОбъекта.ПривестиЗначение(Неопределено);
					ПерваяЗапись = Ложь;
				Иначе
					Запись.ТипОбъекта = Неопределено;
				КонецЕсли;
			КонецЦикла;
			НаборЗаписей.Записать();
		КонецЦикла;
	КонецЕсли;
	
	Если КоличествоДанных < 1000 Тогда
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Управление доступом.Заполнение данных для ограничения доступа'"),
			УровеньЖурналаРегистрации.Информация,
			,
			,
			НСтр("ru = 'Завершено заполнение данных для ограничения доступа.'"),
			РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
			
		Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
			СтандартныеПодсистемыПереопределяемый.УстановитьИспользованиеЗаданияЗаполненияДанныхУправленияДоступом(Ложь);
		Иначе
			Задание = РегламентныеЗадания.НайтиПредопределенное(
				Метаданные.РегламентныеЗадания.ЗаполнениеДанныхДляОграниченияДоступа);
			
			Задание.Использование = Ложь;
			Задание.Записать();
		КонецЕсли;
	Иначе
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Управление доступом.Заполнение данных для ограничения доступа'"),
			УровеньЖурналаРегистрации.Информация,
			,
			,
			НСтр("ru = 'Выполнена запись порции данных для ограничения доступа.'"),
			РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
			
		Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
			СтандартныеПодсистемыПереопределяемый.УстановитьИспользованиеЗаданияЗаполненияДанныхУправленияДоступом(Истина);
		Иначе
			Задание = РегламентныеЗадания.НайтиПредопределенное(
				Метаданные.РегламентныеЗадания.ЗаполнениеДанныхДляОграниченияДоступа);
			Задание.Использование = Истина;
			Задание.Записать();
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с пользователями и группами пользователей

// Обновляет группировки пользователей после обновления составов групп пользователей
// используемых для выполнения проверок разрешенных пользователей.
//
// Параметры:
//  УчастникиИзменений - Массив значений типов:
//                       - СправочникСсылка.Пользователи.
//                       - СправочникСсылка.ВнешниеПользователи.
//                       Пользователи которые участвовали в изменении состава групп.
//
//  ИзмененныеГруппы   - Массив значений типов:
//                       - СправочникСсылка.ГруппыПользователей.
//                       - СправочникСсылка.ГруппыВнешнихПользователей.
//                       Группы, состав которых был изменен.
//
Процедура ПослеОбновленияСоставовГруппПользователей(УчастникиИзменений, ИзмененныеГруппы) Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("Пользователи",        УчастникиИзменений);
	Параметры.Вставить("ГруппыПользователей", ИзмененныеГруппы);
	
	РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей(Параметры);
	
КонецПроцедуры

// Обновляет связь для новой группы пользователей (группы внешних пользователей).
//
// Параметры:
//  Ссылка     - СправочникСсылка.Пользователи.
//             - СправочникСсылка.ГруппыПользователей.
//             - СправочникСсылка.ВнешниеПользователи.
//             - СправочникСсылка.ГруппыВнешнихПользователей.
//
//  ЭтоНовый   - Булево, если Истина, объект был добавлен, иначе изменен.
//
Процедура ПослеДобавленияИзмененияПользователяИлиГруппы(Ссылка, ЭтоНовый) Экспорт
	
	Если ЭтоНовый Тогда
		Если ТипЗнч(Ссылка) = Тип("СправочникСсылка.ГруппыПользователей")
		 ИЛИ ТипЗнч(Ссылка) = Тип("СправочникСсылка.ГруппыВнешнихПользователей") Тогда
		
			Параметры = Новый Структура;
			Параметры.Вставить("ГруппыПользователей", Ссылка);
			РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей(Параметры);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Обновляет группировки внешних пользователей по объекту авторизации.
//
// Параметры:
//  ВнешнийПользователь     - СправочникСсылка.ВнешниеПользователи.
//  СтарыйОбъектАвторизации - NULL - при добавлении внешнего пользователя.
//                            Например, СправочникСсылка.ФизическиеЛица.
//  НовыйОбъектАвторизации  - Например, СправочникСсылка.ФизическиеЛица.
//
Процедура ПослеИзмененияОбъектаАвторизацииВнешнегоПользователя(ВнешнийПользователь,
                                                               СтарыйОбъектАвторизации = Неопределено,
                                                               НовыйОбъектАвторизации) Экспорт
	
	ОбъектыАвторизации = Новый Массив;
	Если СтарыйОбъектАвторизации <> NULL Тогда
		ОбъектыАвторизации.Добавить(СтарыйОбъектАвторизации);
	КонецЕсли;
	ОбъектыАвторизации.Добавить(НовыйОбъектАвторизации);
	
	Параметры = Новый Структура;
	Параметры.Вставить("ОбъектыАвторизации", ОбъектыАвторизации);
	
	РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей(Параметры);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с видами доступа

// Возвращает использование вида доступа.
// Параметры:
//  ВидДоступа   - ПланВидовХарактеристикСсылка.ВидыДоступа.
//
// Возвращаемое значение:
//  Булево.
//
Функция ВидДоступаИспользуется(Знач ВидДоступа) Экспорт
	
	СвойстваВидаДоступа = СвойстваВидаДоступа(ВидДоступа);
	ТипыВидаДоступа = СвойстваВидаДоступа.Таблицы;
	
	Используется = Ложь;
	
	Для Каждого ТипВидаДоступа Из ТипыВидаДоступа Цикл
		ВидДоступаОМД = Метаданные.НайтиПоПолномуИмени(ТипВидаДоступа);
		
		Если ОбщегоНазначения.ОбъектМетаданныхДоступенПоФункциональнымОпциям(ВидДоступаОМД) Тогда
			Используется = Истина;
		КонецЕсли;
	КонецЦикла;
	
	УправлениеДоступомПереопределяемый.ЗаполнитьИспользованиеВидаДоступа(ВидДоступа, Используется);
	
	Возврат Используется;
	
КонецФункции

// Возвращает свойства вида доступа или всех видов доступа.
//
// Параметры:
//  ВидДоступа   - Строка, ПланВидовХарактеристикСсылка.ВидыДоступа, Неопределено.
//
// Возвращаемое значение:
//  Неопределено - когда для вида доступа свойств не найдено,
//  ТаблицаЗначений или Структура со свойствами,
//      описание которых см. в комментарии к функции
//      ПланыВидовХарактеристик.ВидыДоступа.СвойстваВидовДоступа().
//
Функция СвойстваВидаДоступа(Знач ВидДоступа = Неопределено) Экспорт
	
	Свойства = УправлениеДоступомСлужебныйПовтИсп.Параметры().СвойстваВидовДоступа;
	
	Если ВидДоступа = Неопределено Тогда
		Возврат Свойства.Таблица.Получить();
		
	ИначеЕсли ТипЗнч(ВидДоступа) = Тип("Строка") Тогда
		Возврат Свойства.ПоИменам.Получить(ВидДоступа);
		
	КонецЕсли;
	
	Возврат Свойства.ПоСсылкам.Получить(ВидДоступа);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с наборами значений доступа

// Заполняет вспомогательные данные, ускоряющие работу шаблонов ограничений доступа.
//  Выполняется перед записью в регистр НаборыЗначенийДоступа или
// перед записью объекта с табличной частью НаборыЗначенийДоступа.
//
// Параметры:
//  СсылкаНаОбъект - СправочникСсылка.*, ДокументСсылка.*, ...
//  Таблица        - ТабличнаяЧасть (или ТаблицаЗначений), РегистрСведенийНаборЗаписей.НаборыЗначенийДоступа
//
Процедура ПодготовкаНаборовЗначенийДоступаПередЗаписью(СсылкаНаОбъект, Таблица) Экспорт
	
	ПодготовкаНабораЗаписей = ТипЗнч(Таблица) = Тип("РегистрСведенийНаборЗаписей.НаборыЗначенийДоступа");
	
	// Нормализация ресурсов Чтение, Добавление, Изменение, Удаление.
	НомерНабора = -1;
	Для каждого Строка Из Таблица Цикл
		
		Если ПодготовкаНабораЗаписей Тогда
			// Установка значения измерения Объект
			Строка.Объект = СсылкаНаОбъект;
			// Заполнение свойств вида доступа:
			//   ВидДоступаБезГруппЗначенияДоступа,
			//   ВидДоступаЕдинственныйДляТипаЗначенияДоступа,
			//   ВидДоступаЧерезПраваПоЗначениямДоступа
			СвойстваВидаДоступа = СвойстваВидаДоступа(Строка.ВидДоступа);
			Если СвойстваВидаДоступа <> Неопределено Тогда
				ЗаполнитьЗначенияСвойств(Строка, СвойстваВидаДоступа(Строка.ВидДоступа));
			КонецЕсли;
			// Установка типа объекта для одной строки всех наборов (в качестве типа пустая ссылка)
			Если НомерНабора = -1 Тогда
				ТипыОбъекта = Новый Массив;
				ТипыОбъекта.Добавить(ТипЗнч(СсылкаНаОбъект));
				ОписаниеТипаОбъекта = Новый ОписаниеТипов(ТипыОбъекта);
				Строка.ТипОбъекта = ОписаниеТипаОбъекта.ПривестиЗначение(Неопределено);
			КонецЕсли;
			// Установка типа значения доступа для значений доступа по видам доступа
			// ПравоЧтения, ПравоДобавления, ПравоИзменения (в качестве типа пустая ссылка)
			Если Строка.ВидДоступа = ПланыВидовХарактеристик.ВидыДоступа.ПравоЧтения
			 ИЛИ Строка.ВидДоступа = ПланыВидовХарактеристик.ВидыДоступа.ПравоДобавления
			 ИЛИ Строка.ВидДоступа = ПланыВидовХарактеристик.ВидыДоступа.ПравоИзменения Тогда
				МенеджерОбъекта = ?(Строка.ЗначениеДоступа <> Неопределено, ОбщегоНазначения.МенеджерОбъектаПоСсылке(Строка.ЗначениеДоступа), Неопределено);
				Если МенеджерОбъекта <> Неопределено Тогда
					Строка.ТипЗначенияДоступа = МенеджерОбъекта.ПустаяСсылка();
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		// Очистка флажков прав и соответствующих им вторичных данных
		// для всех строк каждого набора, кроме первой строки
		Если НомерНабора = Строка.НомерНабора Тогда
			Строка.Чтение     = Ложь;
			Строка.Добавление = Ложь;
			Строка.Изменение  = Ложь;
			Строка.Удаление   = Ложь;
		Иначе
			НомерНабора = Строка.НомерНабора;
		КонецЕсли;
		
		Если ПодготовкаНабораЗаписей Тогда
			// Описание прав Чтение, Добавление, Изменение через ссылки видов доступа для
			// оптимизации работы механизма зависимостей по правам в шаблоне ограничения доступа
			Строка.ВидДоступаПравоЧтения     = ?(Строка.Чтение,     ПланыВидовХарактеристик.ВидыДоступа.ПравоЧтения,     ПланыВидовХарактеристик.ВидыДоступа.ПустаяСсылка());
			Строка.ВидДоступаПравоДобавления = ?(Строка.Добавление, ПланыВидовХарактеристик.ВидыДоступа.ПравоДобавления, ПланыВидовХарактеристик.ВидыДоступа.ПустаяСсылка());
			Строка.ВидДоступаПравоИзменения  = ?(Строка.Изменение,  ПланыВидовХарактеристик.ВидыДоступа.ПравоИзменения,  ПланыВидовХарактеристик.ВидыДоступа.ПустаяСсылка());
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Возвращает новые наборы для заполнения табличной части.
Функция ПолучитьНаборыЗначенийДоступаТабличнойЧасти(Объект) Экспорт
	
	СсылкаНаОбъект = Объект.Ссылка;
	ТипЗначенияОбъект = ТипЗнч(Объект);
	
	Если Объект.Метаданные().ТабличныеЧасти.Найти("НаборыЗначенийДоступа") = Неопределено Тогда
		ВызватьИсключение(
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверные параметры.
				           |Тип объекта ""%1""
				           |не найдена табличная часть ""Наборы значений доступа"".'"),
				ТипЗначенияОбъект));
	КонецЕсли;
	
	Таблица = УправлениеДоступом.ТаблицаНаборыЗначенийДоступа();
	
	Если УправлениеДоступом.ОграничиватьДоступНаУровнеЗаписей() Тогда
		
		Если НЕ Метаданные.ПодпискиНаСобытия.ЗаписатьНаборыЗначенийДоступа.Источник.СодержитТип(ТипЗначенияОбъект) И
		     НЕ Метаданные.ПодпискиНаСобытия.ЗаписатьЗависимыеНаборыЗначенийДоступа.Источник.СодержитТип(ТипЗначенияОбъект) Тогда
			ВызватьИсключение(
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Неверные параметры.
					           |Тип объекта ""%1""
					           |не найден ни в одной из подписок на события
					           |""Записать наборы значений доступа"",
					           |""Записать зависимые наборы значений доступа"".'"),
					ТипЗначенияОбъект));
		КонецЕсли;
		
		Объект.ЗаполнитьНаборыЗначенийДоступа(Таблица);
		
		Если Таблица.Количество() = 0 Тогда
			// Если это условие отключить, тогда зациклится регламентное задание
			// заполнения данных для ограничения доступа.
			ВызватьИсключение(
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Объект ""%1"" сформировал пустой набор значений доступа.'"),
					ТипЗначенияОбъект));
		КонецЕсли;
		
		УправлениеДоступом.ДобавитьНаборыЗначенийДоступа(Таблица, УправлениеДоступом.ТаблицаНаборыЗначенийДоступа(), Ложь, Истина);
		
		ПодготовкаНаборовЗначенийДоступаПередЗаписью(СсылкаНаОбъект, Таблица);
		
	КонецЕсли;
	
	Возврат Таблица;
	
КонецФункции

// Перезаписывает наборы значений доступа проверяемого объекта
// в РегистрСведений.НаборыЗначенийДоступа, используя процедуру
// УправлениеДоступом.ЗаполнитьНаборыЗначенийДоступа().
//
//  Процедура вызывается из УправлениеДоступомСлужебный.ЗаписатьНаборыЗначенийДоступа(),
// но может быть вызвана из любого места, например,
// при включении ограничения доступа на уровне записей.
//
// Вызывает процедуру прикладного разработчика
// УправлениеДоступомПереопределяемый.ПриИзмененииНаборовЗначенийДоступа(),
// которая используется для перезаписи зависимых наборов значений доступа.
//
// Параметры:
//  Объект       - СправочникОбъект, ДокументОбъект, ..., или СправочникСсылка, ДокументСсылка, ...
//                 В случае вызова с клиента можно передать только ссылку, а нужен объект.
//                 Если получена ссылка, то по ней будет получен объект.
//
Процедура ЗаписатьНаборыЗначенийДоступа(Знач Объект) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Если передача параметра Объект производилась с клиента на сервер,
	// то передавалась ссылка, и объект требуется получить.
	Объект = ?(Объект = Объект.Ссылка, Объект.ПолучитьОбъект(), Объект);
	СсылкаНаОбъект = Объект.Ссылка;
	ТипЗначенияОбъект = ТипЗнч(Объект);
	
	Если НЕ Метаданные.ПодпискиНаСобытия.ЗаписатьНаборыЗначенийДоступа.Источник.СодержитТип(ТипЗначенияОбъект) Тогда
		ВызватьИсключение(
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверные параметры.
				           |Тип объекта ""%1""
				           |не найден в подписке на события
				           |""Записать наборы значений доступа"".'"),
				ТипЗначенияОбъект));
	КонецЕсли;
	
	Если Метаданные.РегистрыСведений.НаборыЗначенийДоступа.Измерения.Объект.Тип.Типы().Найти(ТипЗнч(СсылкаНаОбъект)) = Неопределено Тогда
		ВызватьИсключение(
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка при записи наборов значений доступа:
				           |в регистре сведений НаборыЗначенийДоступа в измерении Объект
				           |не задан тип %1'"),
				СсылкаНаОбъект.Метаданные().ПолноеИмя()));
	КонецЕсли;
	
	НаборЗаписей = РегистрыСведений.НаборыЗначенийДоступа.СоздатьНаборЗаписей();
	
	Если УправлениеДоступом.ОграничиватьДоступНаУровнеЗаписей() Тогда
		
		Если Метаданные.НайтиПоТипу(ТипЗначенияОбъект).ТабличныеЧасти.Найти("НаборыЗначенийДоступа") = Неопределено Тогда
			
			УправлениеДоступом.ЗаполнитьНаборыЗначенийДоступа(Объект, НаборЗаписей);
			
			УправлениеДоступом.ДобавитьНаборыЗначенийДоступа(
				НаборЗаписей, УправлениеДоступом.ТаблицаНаборыЗначенийДоступа(), Ложь, Истина);
		Иначе
			// Записан объект с уже заполненной табличной частью НаборыЗначенийДоступа
			НаборЗаписей.Загрузить(Объект.НаборыЗначенийДоступа.Выгрузить());
		КонецЕсли;
		
		НаборЗаписей.Отбор.Объект.Установить(СсылкаНаОбъект);
		ПодготовкаНаборовЗначенийДоступаПередЗаписью(СсылкаНаОбъект, НаборЗаписей);
		Если НаборыЗначенийДоступаРегистраИзменены(СсылкаНаОбъект, НаборЗаписей) Тогда
			НаборЗаписей.Записать();
			ПриИзмененииНаборовЗначенийДоступа(СсылкаНаОбъект);
		КонецЕсли;
	Иначе
		Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ИСТИНА КАК ЗначениеИстина
		|ИЗ
		|	РегистрСведений.НаборыЗначенийДоступа КАК НаборыЗначенийДоступа
		|ГДЕ
		|	НаборыЗначенийДоступа.Объект = &СсылкаНаОбъект");
		
		Запрос.УстановитьПараметр("СсылкаНаОбъект", СсылкаНаОбъект);
		
		Если НЕ Запрос.Выполнить().Пустой() Тогда
			// Очистка устаревшего набора.
			// Запись нового набора будет выполнена регламентным заданием,
			// после включения ограничения на уровне записей.
			НаборЗаписей.Отбор.Объект.Установить(СсылкаНаОбъект);
			НаборЗаписей.Записать();
			
			// Очистка устаревших зависимых наборов.
			ПриИзмененииНаборовЗначенийДоступа(СсылкаНаОбъект);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Перезаписывает наборы значений доступа зависимых объектов.
//
//  Процедура вызывается из УправлениеДоступомСлужебный.ЗаписатьЗависимыеНаборыЗначенийДоступа(),
// состав типов подписки дополняет (без пересечения) состав типов подписки ЗаписатьНаборыЗначенийДоступа,
// теми типами, для которых выполнять запись наборов в регистр сведений НаборыЗначенийДоступа
// не требуется, но сами наборы входят в состав других наборов, например, наборы некоторых файлов
// из справочника "Файлы" могут входить в состав некоторых бизнес-процессов "Задание", созданных
// на основании файлов, при этом наборы файлов записывать в регистр не требуется.
//
// Вызывает процедуру прикладного разработчика
// УправлениеДоступомПереопределяемый.ПриИзмененииНаборовЗначенийДоступа(),
// которая используется для перезаписи зависимых наборов значений доступа,
// то есть организуется рекурсия.
//
// Параметры:
//  Объект       - СправочникОбъект, ДокументОбъект, ..., или СправочникСсылка, ДокументСсылка, ...
//                 В случае вызова с клиента можно передать только ссылку, а нужен объект.
//                 Если получена ссылка, то по ней будет получен объект.
//
Процедура ЗаписатьЗависимыеНаборыЗначенийДоступа(Знач Объект) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Если передача параметра Объект производилась с клиента на сервер,
	// то передавалась ссылка, и объект требуется получить.
	Объект = ?(Объект = Объект.Ссылка, Объект.ПолучитьОбъект(), Объект);
	СсылкаНаОбъект = Объект.Ссылка;
	ТипЗначенияОбъект = ТипЗнч(Объект);
	
	Если НЕ Метаданные.ПодпискиНаСобытия.ЗаписатьЗависимыеНаборыЗначенийДоступа.Источник.СодержитТип(ТипЗначенияОбъект) Тогда
		ВызватьИсключение(
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверные параметры.
				           |Тип объекта ""%1""
				           |не найден в подписке на события
				           |""Записать зависимые наборы значений доступа"".'"),
				ТипЗначенияОбъект));
	КонецЕсли;
	
	ПриИзмененииНаборовЗначенийДоступа(СсылкаНаОбъект);
	
КонецПроцедуры

// Проверяет, что наборы в табличной части отличаются от новых наборов.
Функция НаборыЗначенийДоступаТабличнойЧастиИзменены(СсылкаНаОбъект, НовыеНаборы) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("СтарыеНаборы", ОбщегоНазначения.ЗначениеРеквизитаОбъекта(СсылкаНаОбъект, "НаборыЗначенийДоступа"));
	Запрос.УстановитьПараметр("НовыеНаборы",  НовыеНаборы);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	НовыеНаборы.НомерНабора,
	|	НовыеНаборы.ВидДоступа,
	|	НовыеНаборы.ЗначениеДоступа,
	|	НовыеНаборы.Чтение,
	|	НовыеНаборы.Добавление,
	|	НовыеНаборы.Изменение,
	|	НовыеНаборы.Удаление
	|ПОМЕСТИТЬ НовыеНаборы
	|ИЗ
	|	&НовыеНаборы КАК НовыеНаборы
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	СтарыеНаборы.НомерНабора,
	|	СтарыеНаборы.ВидДоступа,
	|	СтарыеНаборы.ЗначениеДоступа,
	|	СтарыеНаборы.Чтение,
	|	СтарыеНаборы.Добавление,
	|	СтарыеНаборы.Изменение,
	|	СтарыеНаборы.Удаление
	|ПОМЕСТИТЬ СтарыеНаборы
	|ИЗ
	|	&СтарыеНаборы КАК СтарыеНаборы
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	СтарыеНаборы КАК СтарыеНаборы
	|		ЛЕВОЕ СОЕДИНЕНИЕ НовыеНаборы КАК НовыеНаборы
	|		ПО СтарыеНаборы.НомерНабора = НовыеНаборы.НомерНабора
	|			И СтарыеНаборы.ВидДоступа = НовыеНаборы.ВидДоступа
	|			И СтарыеНаборы.ЗначениеДоступа = НовыеНаборы.ЗначениеДоступа
	|			И СтарыеНаборы.Чтение = НовыеНаборы.Чтение
	|			И СтарыеНаборы.Добавление = НовыеНаборы.Добавление
	|			И СтарыеНаборы.Изменение = НовыеНаборы.Изменение
	|			И СтарыеНаборы.Удаление = НовыеНаборы.Удаление
	|ГДЕ
	|	НовыеНаборы.НомерНабора ЕСТЬ NULL 
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА
	|ИЗ
	|	НовыеНаборы КАК НовыеНаборы
	|		ЛЕВОЕ СОЕДИНЕНИЕ СтарыеНаборы КАК СтарыеНаборы
	|		ПО (СтарыеНаборы.НомерНабора = НовыеНаборы.НомерНабора)
	|			И (СтарыеНаборы.ВидДоступа = НовыеНаборы.ВидДоступа)
	|			И (СтарыеНаборы.ЗначениеДоступа = НовыеНаборы.ЗначениеДоступа)
	|			И (СтарыеНаборы.Чтение = НовыеНаборы.Чтение)
	|			И (СтарыеНаборы.Добавление = НовыеНаборы.Добавление)
	|			И (СтарыеНаборы.Изменение = НовыеНаборы.Изменение)
	|			И (СтарыеНаборы.Удаление = НовыеНаборы.Удаление)
	|ГДЕ
	|	СтарыеНаборы.НомерНабора ЕСТЬ NULL ";
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для действий при изменений настроек подсистемы

// Если необходимо, включает заполнение данных для ограничения доступа и
// обновляет некоторые данные сразу.
//
// Вызывается из обработчика ПриЗаписи константы ОграничиватьДоступаНаУровнеЗаписей.
//
Процедура ПриИзмененииОграниченияДоступаНаУровнеЗаписей(ОграничениеДоступаНаУровнеЗаписейВключено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ОграничениеДоступаНаУровнеЗаписейВключено Тогда
		
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Управление доступом.Заполнение данных для ограничения доступа'"), 
			УровеньЖурналаРегистрации.Информация,
			,
			,
			НСтр("ru = 'Начато заполнение данных для ограничения доступа.'"),
			РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
		
		Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
			
			СтандартныеПодсистемыПереопределяемый.
				УстановитьИспользованиеЗаданияЗаполненияДанныхУправленияДоступом(Истина);
		Иначе
			Задание = РегламентныеЗадания.НайтиПредопределенное(
				Метаданные.РегламентныеЗадания.ЗаполнениеДанныхДляОграниченияДоступа);
			Задание.Использование = Истина;
			Задание.Записать();
		КонецЕсли;
	КонецЕсли;
	
	// Обновление параметров сеанса.
	// Требуется для того, чтобы администратор не выполнял перезапуск.
	УстановленныеПараметры = Новый Массив;
	УстановкаПараметровСеанса("ОграничиватьДоступПоВиду", УстановленныеПараметры);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы интерфейсов пользователей

// Возвращает список значений доступа не помеченных на удаление.
//  Используется в обработчиках событий ОкончаниеВводаТекста и АвтоПодбор.
//
// Параметры:
//  Текст         - Строка, символы введенные пользователем.
//  ВключаяГруппы - Булево, если Истина, включать группы пользователей и внешних пользователей.
//  ВидДоступа    - ПланыВидовХарактеристикСсылка.ВидыДоступа, значения доступа которого выбираются.
//
Функция СформироватьДанныеВыбораЗначенияДоступа(Знач Текст, Знач ВидДоступа, ВключаяГруппы = Истина) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Текст", Текст + "%");
	Запрос.УстановитьПараметр("ВключаяГруппы", ВключаяГруппы);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ПредставленияПеречислений.Ссылка,
	|	ПредставленияПеречислений.Наименование КАК Наименование
	|ПОМЕСТИТЬ ПредставленияПеречислений
	|ИЗ
	|	&ПредставленияПеречислений КАК ПредставленияПеречислений
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	НЕОПРЕДЕЛЕНО КАК Ссылка,
	|	"""" КАК Наименование
	|ГДЕ
	|	ЛОЖЬ";
	
	ЗапросПредставленийПеречислений = Новый Запрос;
	ЗапросПредставленийПеречислений.Текст =
	"ВЫБРАТЬ
	|	"""" КАК Ссылка,
	|	"""" КАК Наименование
	|ГДЕ
	|	ЛОЖЬ";
	
	Для каждого Тип Из ВидДоступа.ТипЗначения.Типы() Цикл
		
		МетаданныеТипа = Метаданные.НайтиПоТипу(Тип);
		
		ПолноеИмяТаблицы = МетаданныеТипа.ПолноеИмя();
		
		Если (     Метаданные.Справочники.Содержит(МетаданныеТипа)
		       ИЛИ Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеТипа) )
		   И МетаданныеТипа.Иерархический
		   И МетаданныеТипа.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов
		   И НЕ ВключаяГруппы Тогда
			
			УсловиеДляГруппы = "НЕ Таблица.ЭтоГруппа";
		Иначе
			УсловиеДляГруппы = "Истина";
		КонецЕсли;
		
		Если Метаданные.Перечисления.Содержит(МетаданныеТипа) Тогда
			//
			ЗапросПредставленийПеречислений.Текст = ЗапросПредставленийПеречислений.Текст + Символы.ПС + Символы.ПС + " ОБЪЕДИНИТЬ ВСЕ "  + Символы.ПС + Символы.ПС;
			ЗапросПредставленийПеречислений.Текст = ЗапросПредставленийПеречислений.Текст + СтрЗаменить(
			"ВЫБРАТЬ
			|	Таблица.Ссылка,
			|	ПРЕДСТАВЛЕНИЕ(Таблица.Ссылка) КАК Наименование
			|ИЗ
			|	&ПолноеИмяТаблицы КАК Таблица", "&ПолноеИмяТаблицы", ПолноеИмяТаблицы);
		Иначе
			Запрос.Текст = Запрос.Текст + Символы.ПС + Символы.ПС + " ОБЪЕДИНИТЬ ВСЕ "  + Символы.ПС + Символы.ПС;
			Запрос.Текст = Запрос.Текст + СтрЗаменить(СтрЗаменить(
			"ВЫБРАТЬ
			|	Таблица.Ссылка,
			|	Таблица.Наименование
			|ИЗ
			|	&ПолноеИмяТаблицы КАК Таблица
			|ГДЕ
			|	(НЕ Таблица.ПометкаУдаления)
			|	И Таблица.Наименование ПОДОБНО &Текст
			|	И &УсловиеДляГруппы", "&ПолноеИмяТаблицы", ПолноеИмяТаблицы), "&УсловиеДляГруппы", УсловиеДляГруппы);
		КонецЕсли;
	КонецЦикла;
	
	Запрос.УстановитьПараметр("ПредставленияПеречислений", ЗапросПредставленийПеречислений.Выполнить().Выгрузить());
	Запрос.Текст = Запрос.Текст + Символы.ПС + Символы.ПС + " ОБЪЕДИНИТЬ ВСЕ "  + Символы.ПС + Символы.ПС;
	Запрос.Текст = Запрос.Текст +
	"ВЫБРАТЬ
	|	ПредставленияПеречислений.Ссылка,
	|	ПредставленияПеречислений.Наименование
	|ИЗ
	|	ПредставленияПеречислений КАК ПредставленияПеречислений
	|ГДЕ
	|	ПредставленияПеречислений.Наименование ПОДОБНО &Текст";
	
	ДанныеВыбора = Новый СписокЗначений;
	

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		
		ДанныеВыбора.Добавить(Выборка.Ссылка, Выборка.Наименование);
	КонецЦикла;
	
	Возврат ДанныеВыбора;
	
КонецФункции

// Заполняет шаблон заголовка подчиненной формы свойствами ссылки-владельца,
// например, НСтр("ru = 'Права доступа: %1 (%2)'" -> "Права доступа: Иванов (Пользователь)".
//
// Параметры:
//  СсылкаНаВладельца - ссылка на объект-владелец.
//
Функция ЗаголовокПодчиненнойФормы(СтрокаЗаголовкаСПараметрами, СсылкаНаВладельца) Экспорт
	
	МетаданныеВладельца   = СсылкаНаВладельца.Метаданные();
	НаименованиеВладельца = Строка(СсылкаНаВладельца);
	
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					СтрокаЗаголовкаСПараметрами,
					НаименованиеВладельца,
					НазваниеОбъектаИзМетаданных(МетаданныеВладельца) );
	
КонецФункции

// Возвращает название объекта метаданных с учетом заданных свойств в порядке:
//  - РасширенноеПредставлениеОбъекта,
//  - ПредставлениеОбъекта,
//  - Синоним,
//  - Имя.
//
// Параметры:
//  МетаданныеОбъекта - ОбъектМетаданных.
//
// Возвращаемое значение:
//  Строка.
//
Функция НазваниеОбъектаИзМетаданных(МетаданныеОбъекта) Экспорт
	
	Если ЗначениеЗаполнено(МетаданныеОбъекта.РасширенноеПредставлениеОбъекта) Тогда
		НазваниеОбъекта = МетаданныеОбъекта.РасширенноеПредставлениеОбъекта;
	ИначеЕсли ЗначениеЗаполнено(МетаданныеОбъекта.ПредставлениеОбъекта) Тогда
		НазваниеОбъекта = МетаданныеОбъекта.ПредставлениеОбъекта;
	ИначеЕсли ЗначениеЗаполнено(МетаданныеОбъекта.Синоним) Тогда
		НазваниеОбъекта = МетаданныеОбъекта.Синоним;
	Иначе
		НазваниеОбъекта = МетаданныеОбъекта.Имя;
	КонецЕсли;
	
	Возврат НазваниеОбъекта;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Универсальные процедуры и функции

// Возвращает ссылку старого объекта или ссылку нового объекта.
//
// Параметры:
//  Объект       - СправочникОбъект, ...
//  ЭтоНовый     - Булево (Возвращаемое значение).
//
Функция СсылкаОбъекта(Знач Объект, ЭтоНовый = Неопределено) Экспорт
	
	Ссылка = Объект.Ссылка;
	ЭтоНовый = НЕ ЗначениеЗаполнено(Ссылка);
	
	Если ЭтоНовый Тогда
		Ссылка = Объект.ПолучитьСсылкуНового();
		
		Если НЕ ЗначениеЗаполнено(Ссылка) Тогда
			
			Менеджер = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Объект.Ссылка);
			Ссылка = Менеджер.ПолучитьСсылку();
			Объект.УстановитьСсылкуНового(Ссылка);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ссылка;
	
КонецФункции

// Только для внутреннего использования
Процедура УстановитьУсловиеОтбораВЗапросе(Знач Запрос, Знач Значения, Знач ИмяПараметраЗначений, Знач ИмяПараметраУсловияОтбораИмяПоля) Экспорт
	
	Если Значения = Неопределено Тогда
		
	ИначеЕсли ТипЗнч(Значения) <> Тип("Массив")
	        И ТипЗнч(Значения) <> Тип("ФиксированныйМассив") Тогда
		
		Запрос.УстановитьПараметр(ИмяПараметраЗначений, Значения);
		
	ИначеЕсли Значения.Количество() = 1 Тогда
		Запрос.УстановитьПараметр(ИмяПараметраЗначений, Значения[0]);
	Иначе
		Запрос.УстановитьПараметр(ИмяПараметраЗначений, Значения);
	КонецЕсли;
	
	Для НомерСтроки = 1 По СтрЧислоСтрок(ИмяПараметраУсловияОтбораИмяПоля) Цикл
		ТекущаяСтрока = СтрПолучитьСтроку(ИмяПараметраУсловияОтбораИмяПоля, НомерСтроки);
		Если НЕ ЗначениеЗаполнено(ТекущаяСтрока) Тогда
			Продолжить;
		КонецЕсли;
		ИндексРазделителя = Найти(ТекущаяСтрока, ":");
		Если ИндексРазделителя = 0 Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка при выполнении процедуры УправлениеДоступом.УстановитьУсловиеОтбораВЗапросе().
				           |
				           |В параметре ИмяПараметраУсловияОтбораИмяПоля не найден разделитель (двоеточие)
				           |в следующей строке формата ""<Имя параметра условия>:<Имя поля>""
				           |""%1"".'"),
				ТекущаяСтрока);
		КонецЕсли;
		ИмяПараметраУсловияОтбора = Лев(ТекущаяСтрока, ИндексРазделителя-1);
		ИмяПоля = Сред(ТекущаяСтрока, ИндексРазделителя+1);
		Если Значения = Неопределено Тогда
			УсловиеОтбора = "Истина";
			
		ИначеЕсли ТипЗнч(Значения) <> Тип("Массив")
		        И ТипЗнч(Значения) <> Тип("ФиксированныйМассив") Тогда
			
			УсловиеОтбора = ИмяПоля + " = &" + ИмяПараметраЗначений;
			
		ИначеЕсли Значения.Количество() = 1 Тогда
			УсловиеОтбора = ИмяПоля + " = &" + ИмяПараметраЗначений;
		Иначе
			УсловиеОтбора = ИмяПоля + " В (&" + ИмяПараметраЗначений + ")";
		КонецЕсли;
		Запрос.Текст = СтрЗаменить(Запрос.Текст, ИмяПараметраУсловияОтбора, УсловиеОтбора);
	КонецЦикла;
	
КонецПроцедуры

// Обновляет набор записей в базе данных,
// если записи набора отличаются от записей в базе данных.
//
// Параметры:
//  НаборЗаписей         - НаборЗаписей пустой или прочитанный с заданным отбором или без отбора.
//                         Менеджер регистра для создания набора записей.
//
//  НовыеЗаписи          - ТаблицаЗначений в формате регистра.
//
//  ПоляСравнения        - Строка - содержит список полей по значениям которых требуется вычислять
//                         отличие записей набора. Например, "Измерение1, Измерение2, Ресурс1",
//                         а реквизит ДатаИзмерения не входит в список.
//
//  ПолеОтбора           - Неопределено - записывается весь регистр или
//                                        отбор уже задан в наборе записей.
//                         Строка       - имя поля по которому нужно установить отбор.
//
//  ЗначениеОтбора       - значение, которое будет установлено в качестве отбора по полю отбора,
//                         если поле отбора задано.
//
//  ИзмененныеЗаписи      - Неопределено - никаких действий, иначе
//                         возвращает таблицу значений в формате регистра с полем ВидИзмененияСтроки
//                         типа Число (-1 запись удалена, 1 запись добавлена).
//
//  ТранзакцияОткрыта    - Неопределено    - не открывать транзакцию.
//                         Истина          - транзакция уже открыта, её не требуется открывать.
//                         Другое значение - требуется открыть транзакцию и
//                                           установить ТранзакцияОткрыта в Истина.
//
//  НаборЗаписейПрочитан - Булево, если Истина, тогда не заданный набор записей уже содержит
//                         прочитанные записи блокировка данных этих записей установлена и
//                         транзакция открыта.
//
//  ЕстьИзменения        - если производилась запись, устанавливается Ложь, иначе не изменяется.
//
Процедура ОбновитьНаборЗаписей(Знач НаборЗаписей,
                               Знач НовыеЗаписи,
                               Знач ПоляСравнения        = Неопределено,
                               Знач ПолеОтбора           = Неопределено,
                               Знач ЗначениеОтбора       = Неопределено,
                               ЕстьИзменения             = Неопределено,
                               ИзмененныеЗаписи          = Неопределено,
                               ТранзакцияОткрыта         = Неопределено,
                               Знач НаборЗаписейПрочитан = Ложь,
                               Знач БезПерезаписи        = Ложь) Экспорт
	
	ПолноеИмяРегистра = Метаданные.НайтиПоТипу(ТипЗнч(НаборЗаписей)).ПолноеИмя();
	МенеджерРегистра = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмяРегистра);
	Если НаборЗаписей = МенеджерРегистра Тогда
		НаборЗаписей = МенеджерРегистра.СоздатьНаборЗаписей();
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПолеОтбора) Тогда
		УстановитьОтбор(НаборЗаписей.Отбор[ПолеОтбора], ЗначениеОтбора);
	КонецЕсли;
	
	Если НЕ НаборЗаписейПрочитан Тогда
		ЗаблокироватьОбластьНабораЗаписей(НаборЗаписей, ПолноеИмяРегистра);
		НаборЗаписей.Прочитать();
	КонецЕсли;
	
	ПоляСравнения = ?(ПоляСравнения = Неопределено, ПоляНабораЗаписей(НаборЗаписей), ПоляСравнения);
	
	Если БезПерезаписи Тогда
		НаборЗаписи = МенеджерРегистра.СоздатьНаборЗаписей();
		ОписаниеКлючаЗаписи = УправлениеДоступомСлужебныйПовтИсп.ОписаниеКлючаЗаписи(ПолноеИмяРегистра);
		ОтборЗаписи = Новый Структура(ОписаниеКлючаЗаписи.СтрокаПолей);
		ПоляОстальныхИзмерений = Новый Массив;
		Для каждого Поле Из ОписаниеКлючаЗаписи.МассивПолей Цикл
			Если Поле <> ПолеОтбора Тогда
				ПоляОстальныхИзмерений.Добавить(Поле);
			КонецЕсли;
		КонецЦикла;
		УдаляемыеЗаписи = Новый ТаблицаЗначений;
		Для каждого Поле Из ПоляОстальныхИзмерений Цикл
			УдаляемыеЗаписи.Колонки.Добавить(Поле);
		КонецЦикла;
		НовыеЗаписи = НовыеЗаписи.Скопировать();
	КонецЕсли;
	
	Если ИзмененныеЗаписи = Неопределено Тогда
		Если НаборЗаписей.Количество() = НовыеЗаписи.Количество() ИЛИ БезПерезаписи Тогда
			Отбор = Новый Структура(ПоляСравнения);
			НовыеЗаписи.Индексы.Добавить(ПоляСравнения);
			Для каждого Запись Из НаборЗаписей Цикл
				ЗаполнитьЗначенияСвойств(Отбор, Запись);
				НайденныеСтроки = НовыеЗаписи.НайтиСтроки(Отбор);
				Если НайденныеСтроки.Количество() = 0 Тогда
					ЕстьИзменения = Истина;
					Если БезПерезаписи Тогда
						ЗаполнитьЗначенияСвойств(ОтборЗаписи, Запись);
						Если НовыеЗаписи.НайтиСтроки(ОтборЗаписи).Количество() = 0 Тогда
							ЗаполнитьЗначенияСвойств(УдаляемыеЗаписи.Добавить(), ОтборЗаписи);
						КонецЕсли;
					Иначе
						Прервать;
					КонецЕсли;
				ИначеЕсли БезПерезаписи Тогда
					НовыеЗаписи.Удалить(НайденныеСтроки[0]);
				КонецЕсли;
			КонецЦикла;
			Если БезПерезаписи И НовыеЗаписи.Количество() > 0 Тогда
				ЕстьИзменения = Истина;
			КонецЕсли;
		Иначе
			ЕстьИзменения = Истина;
		КонецЕсли;
	Иначе
		Если НаборЗаписей.Количество() <> НовыеЗаписи.Количество() Тогда
			ЕстьИзменения = Истина;
		КонецЕсли;
		Если НаборЗаписей.Количество() > НовыеЗаписи.Количество() Тогда
			ИзмененныеЗаписи = НаборЗаписей.Выгрузить();
			ИскомыеЗаписи   = НовыеЗаписи;
			ВидИзмененияСтроки = -1;
		Иначе
			ИзмененныеЗаписи = НовыеЗаписи.Скопировать();
			ИскомыеЗаписи   = НаборЗаписей.Выгрузить();
			ВидИзмененияСтроки = 1;
		КонецЕсли;
		ИзмененныеЗаписи.Колонки.Добавить("ВидИзмененияСтроки", Новый ОписаниеТипов("Число"));
		ИзмененныеЗаписи.ЗаполнитьЗначения(ВидИзмененияСтроки, "ВидИзмененияСтроки");
		ВидИзмененияСтроки = ?(ВидИзмененияСтроки = 1, -1, 1);
		Отбор = Новый Структура(ПоляСравнения);
		
		Для каждого Строка Из ИскомыеЗаписи Цикл
			ЗаполнитьЗначенияСвойств(Отбор, Строка);
			Строки = ИзмененныеЗаписи.НайтиСтроки(Отбор);
			Если Строки.Количество() = 0 Тогда
				НоваяСтрока = ИзмененныеЗаписи.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, Отбор);
				НоваяСтрока.ВидИзмененияСтроки = ВидИзмененияСтроки;
				ЕстьИзменения = Истина;
			Иначе
				ИзмененныеЗаписи.Удалить(Строки[0]);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если ЕстьИзменения = Истина Тогда
		Если ТранзакцияОткрыта <> Неопределено // Требуется использовать внешнюю транзакцию
		   И ТранзакцияОткрыта <> Истина Тогда // Внешняя транзакция ещё не открыта
			// Открытие внешней транзакции
			НачатьТранзакцию();
			ТранзакцияОткрыта = Истина;
		КонецЕсли;
		Если БезПерезаписи Тогда
			Для каждого Строка Из УдаляемыеЗаписи Цикл
				Если ЗначениеЗаполнено(ПолеОтбора) Тогда
					УстановитьОтбор(НаборЗаписи.Отбор[ПолеОтбора], ЗначениеОтбора);
				КонецЕсли;
				Для каждого Поле Из ПоляОстальныхИзмерений Цикл
					УстановитьОтбор(НаборЗаписи.Отбор[Поле], Строка[Поле]);
				КонецЦикла;
				НаборЗаписи.Записать();
			КонецЦикла;
			НаборЗаписи.Добавить();
			Для каждого Строка Из НовыеЗаписи Цикл
				Если ЗначениеЗаполнено(ПолеОтбора) Тогда
					УстановитьОтбор(НаборЗаписи.Отбор[ПолеОтбора], ЗначениеОтбора);
				КонецЕсли;
				Для каждого Поле Из ПоляОстальныхИзмерений Цикл
					УстановитьОтбор(НаборЗаписи.Отбор[Поле], Строка[Поле]);
				КонецЦикла;
				ЗаполнитьЗначенияСвойств(НаборЗаписи[0], Строка);
				НаборЗаписи.Записать();
			КонецЦикла;
		Иначе
			НаборЗаписей.Загрузить(НовыеЗаписи);
			НаборЗаписей.Записать();
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Обновляет строки регистра с отбором по нескольким значениям для одного или
// для двух измерений регистра, выполняется проверка наличия изменений,
// если изменений нет, перезапись не производится.
//
// Параметры:
//  МенеджерРегистра          - Менеджер регистра для создания типа <Регистр*>НаборЗаписей.
//
//  НовыеЗаписи               - ТаблицаЗначений в формате регистра.
//
//  ПоляСравнения             - Строка - содержит список полей по значениям которых требуется
//                              вычислять отличие записей набора, например, "Измерение1, Измерение2,
//                              Ресурс1", а реквизит ДатаИзменения не входит в список.
//
//  ИмяПервогоИзмерения       - Неопределено - нет отбора по измерению.
//                              Строка       - содержит имя первого измерения, для которого задано
//                                             несколько значений.
//
//  ЗначенияПервогоИзмерения  - Неопределено - нет отбора по измерению, аналогично,
//                                             ИмяПервогоИзмерения = Неопределено.
//                              ЛюбаяСсылка  - содержит одно значение отбора регистра для
//                                             обновляемых записей.
//                              Массив       - содержит массив значений отбора регистра для
//                                             обновляемых записей, пустой массив - значит
//                                             действий не требуется.
//
//  ИмяВторогоИзмерения       - аналогично ИмяПервогоИзмерения.
//  ЗначенияВторогоИзмерения  - аналогично ЗначенияПервогоИзмерения.
//  ИмяТретьегоИзмерения      - аналогично ИмяПервогоИзмерения.
//  ЗначенияТретьегоИзмерения - аналогично ЗначенияПервогоИзмерения.
//
//  ЕстьИзменения             - если производилась запись, устанавливается Истина,
//                              иначе не изменяется.
//
Процедура ОбновитьНаборыЗаписей(Знач МенеджерРегистра,
                                Знач НовыеЗаписи,
                                Знач ПоляСравнения                     = Неопределено,
                                Знач ИмяПервогоИзмерения               = Неопределено,
                                Знач ЗначенияПервогоИзмерения          = Неопределено,
                                Знач ИмяВторогоИзмерения               = Неопределено,
                                Знач ЗначенияВторогоИзмерения          = Неопределено,
                                Знач ИмяТретьегоИзмерения              = Неопределено,
                                Знач ЗначенияТретьегоИзмерения         = Неопределено,
                                Знач НовыеЗаписиСодержатТолькоРазличия = Ложь,
                                Знач ФиксированныйОтбор                = Неопределено,
                                ЕстьИзменения                          = Неопределено) Экспорт
	
	// Предварительная обработка параметров.
	
	Если НЕ ГруппаПараметровИзмеренияОбработана(ИмяПервогоИзмерения, ЗначенияПервогоИзмерения) Тогда
		ЕстьИзменения = Истина;
		Возврат;
	КонецЕсли;
	Если НЕ ГруппаПараметровИзмеренияОбработана(ИмяВторогоИзмерения, ЗначенияВторогоИзмерения) Тогда
		ЕстьИзменения = Истина;
		Возврат;
	КонецЕсли;
	Если НЕ ГруппаПараметровИзмеренияОбработана(ИмяТретьегоИзмерения, ЗначенияТретьегоИзмерения) Тогда
		ЕстьИзменения = Истина;
		Возврат;
	КонецЕсли;
	
	УпорядочитьГруппыПараметровИзмерений(
		ИмяПервогоИзмерения,
		ЗначенияПервогоИзмерения,
		ИмяВторогоИзмерения,
		ЗначенияВторогоИзмерения,
		ИмяТретьегоИзмерения,
		ЗначенияТретьегоИзмерения);
	
	// Проверка и обновление данных.
	Параметры = Новый Структура;
	Параметры.Вставить("НовыеЗаписи",        НовыеЗаписи);
	Параметры.Вставить("ПоляСравнения",      ПоляСравнения);
	Параметры.Вставить("ФиксированныйОтбор", ФиксированныйОтбор);
	Параметры.Вставить("ТранзакцияОткрыта",  ?(ТранзакцияАктивна(), Неопределено, Ложь));
	Параметры.Вставить("НаборЗаписей",       МенеджерРегистра.СоздатьНаборЗаписей());
	Параметры.Вставить("МетаданныеРегистра", Метаданные.НайтиПоТипу(ТипЗнч(Параметры.НаборЗаписей)));
	Параметры.Вставить("ПолноеИмяРегистра",  Параметры.МетаданныеРегистра.ПолноеИмя());
	
	Если НовыеЗаписиСодержатТолькоРазличия Тогда
		Параметры.Вставить("НаборДляОднойЗаписи",  МенеджерРегистра.СоздатьНаборЗаписей());
	КонецЕсли;
	
	Если Параметры.ФиксированныйОтбор <> Неопределено Тогда
		Для каждого КлючИЗначение Из Параметры.ФиксированныйОтбор Цикл
			УстановитьОтбор(Параметры.НаборЗаписей.Отбор[КлючИЗначение.Ключ], КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Попытка
		Если НовыеЗаписиСодержатТолькоРазличия Тогда
			
			Если ИмяПервогоИзмерения = Неопределено Тогда
				ВызватьИсключение
					НСтр("ru = 'Некорректные параметры в процедуре ОбновитьНаборыЗаписей.'");
			Иначе
				Если ИмяВторогоИзмерения = Неопределено Тогда
					ЗаписьНесколькимиНаборами = Ложь;
				Иначе
					ЗаписьНесколькимиНаборами = ЗаписьНесколькимиНаборами(
						Параметры, Новый Структура, ИмяПервогоИзмерения, ЗначенияПервогоИзмерения);
				КонецЕсли;
				
				Если ЗаписьНесколькимиНаборами Тогда
					СписокПолей = ИмяПервогоИзмерения + ", " + ИмяВторогоИзмерения;
					НовыеЗаписи.Индексы.Добавить(СписокПолей);
					
					КоличествоПоЗначениямПервогоИзмерения = Параметры.КоличествоПоЗначениям;
					
					Для каждого ПервоеЗначение Из ЗначенияПервогоИзмерения Цикл
						Отбор = Новый Структура(ИмяПервогоИзмерения, ПервоеЗначение);
						УстановитьОтбор(Параметры.НаборЗаписей.Отбор[ИмяПервогоИзмерения], ПервоеЗначение);
						
						Если ИмяТретьегоИзмерения = Неопределено Тогда
							ЗаписьНесколькимиНаборами = Ложь;
						Иначе
							ЗаписьНесколькимиНаборами = ЗаписьНесколькимиНаборами(
								Параметры, Отбор, ИмяВторогоИзмерения, ЗначенияВторогоИзмерения);
						КонецЕсли;
						
						Если ЗаписьНесколькимиНаборами Тогда
							Для каждого ВтороеЗначение Из ЗначенияВторогоИзмерения Цикл
								Отбор.Вставить(ИмяВторогоИзмерения, ВтороеЗначение);
								УстановитьОтбор(Параметры.НаборЗаписей.Отбор[ИмяВторогоИзмерения], ВтороеЗначение);
								
								// Обновление по трем измерениям.
								ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям(Параметры, Отбор, ЕстьИзменения);
							КонецЦикла;
							Параметры.НаборЗаписей.Отбор[ИмяВторогоИзмерения].Использование = Ложь;
						Иначе
							// Обновление по двум измерениям.
							Параметры.Вставить("КоличествоПоЗначениям", КоличествоПоЗначениямПервогоИзмерения);
							ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям(Параметры, Отбор, ЕстьИзменения);
						КонецЕсли;
					КонецЦикла;
				Иначе
					// Обновление по одному измерению.
					ПрочитатьКоличествоДляЧтения(Параметры);
					ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям(Параметры, Новый Структура, ЕстьИзменения);
				КонецЕсли;
			КонецЕсли;
		Иначе
			Если ИмяПервогоИзмерения = Неопределено Тогда
				// Обновление всех записей.
				ОбновитьНаборЗаписей(
					Параметры.НаборЗаписей,
					НовыеЗаписи,
					ПоляСравнения,
					,
					,
					ЕстьИзменения,
					,
					Параметры.ТранзакцияОткрыта);
				
			ИначеЕсли ИмяВторогоИзмерения = Неопределено Тогда
				// Обновление по одному измерению.
				Отбор = Новый Структура(ИмяПервогоИзмерения);
				Для каждого Значение Из ЗначенияПервогоИзмерения Цикл
					
					УстановитьОтбор(Параметры.НаборЗаписей.Отбор[ИмяПервогоИзмерения], Значение);
					Отбор[ИмяПервогоИзмерения] = Значение;
					
					Если ЗначенияПервогоИзмерения.Количество() = 1 Тогда
						НовыеЗаписиНабора = НовыеЗаписи;
					Иначе
						НовыеЗаписиНабора = НовыеЗаписи.Скопировать(Отбор);
					КонецЕсли;
					
					ОбновитьНаборЗаписей(
						Параметры.НаборЗаписей,
						НовыеЗаписиНабора,
						ПоляСравнения,
						,
						,
						ЕстьИзменения,
						,
						Параметры.ТранзакцияОткрыта);
				КонецЦикла;
				
			ИначеЕсли ИмяТретьегоИзмерения = Неопределено Тогда
				// Обновление по двум измерениям.
				СписокПолей = ИмяПервогоИзмерения + ", " + ИмяВторогоИзмерения;
				НовыеЗаписи.Индексы.Добавить(СписокПолей);
				Отбор = Новый Структура(СписокПолей);
				
				Для каждого ПервоеЗначение Из ЗначенияПервогоИзмерения Цикл
					УстановитьОтбор(Параметры.НаборЗаписей.Отбор[ИмяПервогоИзмерения], ПервоеЗначение);
					Отбор[ИмяПервогоИзмерения] = ПервоеЗначение;
					
					ОбновитьНовыеЗаписиНабораПоВсемНовымЗаписям(
						Параметры,
						Отбор,
						СписокПолей,
						ИмяВторогоИзмерения,
						ЗначенияВторогоИзмерения,
						ЕстьИзменения);
				КонецЦикла;
			Иначе
				// Обновление по трем измерениям.
				СписокПолей = ИмяПервогоИзмерения + ", " + ИмяВторогоИзмерения + ", " + ИмяТретьегоИзмерения;
				НовыеЗаписи.Индексы.Добавить(СписокПолей);
				Отбор = Новый Структура(СписокПолей);
				
				Для каждого ПервоеЗначение Из ЗначенияПервогоИзмерения Цикл
					УстановитьОтбор(Параметры.НаборЗаписей.Отбор[ИмяПервогоИзмерения], ПервоеЗначение);
					Отбор[ИмяПервогоИзмерения] = ПервоеЗначение;
					
					Для каждого ВтороеЗначение Из ЗначенияВторогоИзмерения Цикл
						УстановитьОтбор(Параметры.НаборЗаписей.Отбор[ИмяВторогоИзмерения], ВтороеЗначение);
						Отбор[ИмяВторогоИзмерения] = ВтороеЗначение;
						
						ОбновитьНовыеЗаписиНабораПоВсемНовымЗаписям(
							Параметры,
							Отбор,
							СписокПолей,
							ИмяВторогоИзмерения,
							ЗначенияВторогоИзмерения,
							ЕстьИзменения);
					КонецЦикла;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		
		Если Параметры.ТранзакцияОткрыта = Истина Тогда
			ЗафиксироватьТранзакцию();
		КонецЕсли;
	Исключение
		Если Параметры.ТранзакцияОткрыта = Истина Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Обновляет строки регистра сведений по данным в таблице значений РазличныеСтроки.
//
// Параметры:
//  МенеджерРегистра   - Менеджер регистра для создания типа <Регистр*>НаборЗаписей.
//
//  РазличныеСтроки    - ТаблицаЗначений, содержащей поля регистра и
//                       поле ВидИзмененияСтроки (Число):
//                         "1" - значит, что строку нужно добавить,
//                         "-1" - значит, что строку нужно удалить.
//
//  ЕстьИзменения      - если производилась запись, устанавливается Истина,
//                       иначе не изменяется.
//
//  ФиксированныйОтбор - Структура, содержащая имя измерения в ключе и значение
//                       отбора в значении. Может быть указана, когда измерений
//                       более 3-х и заранее известно, что по измерениям сверх 3-х
//                       будет единственное значение. Измерения указанные в
//                       фиксированном отборе не используются при формировании
//                       наборов записей для выполнения обновления.
//
//  ИзмеренияОтбора    - Строка измерений перечисленных через запятую, которые
//                       нужно использовать при формировании наборов записей
//                       для выполнения обновления (не более 3-х). Не указанные
//                       измерения будут превращены в фиксированный отбор,
//                       если по ним все значения совпадают.
//
Процедура ОбновитьРегистрСведений(МенеджерРегистра,
                                  ОбновляемыеСтроки,
                                  ЕстьИзменения = Неопределено,
                                  ФиксированныйОтбор = Неопределено,
                                  ИзмеренияОтбора = Неопределено) Экспорт
	
	Если ОбновляемыеСтроки.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	МетаданныеРегистра = Метаданные.НайтиПоТипу(ТипЗнч(МенеджерРегистра.ПустойКлюч()));
	
	Если ФиксированныйОтбор = Неопределено Тогда
		ФиксированныйОтбор = Новый Структура;
	КонецЕсли;
	
	ОписаниеКлючаЗаписи = УправлениеДоступомСлужебныйПовтИсп.ОписаниеКлючаЗаписи(
		МетаданныеРегистра.ПолноеИмя());
	
	Если ИзмеренияОтбора = Неопределено Тогда
		ОтборКлючаЗаписи = Новый Структура(ОписаниеКлючаЗаписи.СтрокаПолей);
	Иначе
		ИзмеренияОтбора = Новый Структура(ИзмеренияОтбора);
	КонецЕсли;
	
	МассивИзмеренийОтбора   = Новый Массив;
	ЗначенияИзмеренийОтбора = Новый Структура;
	
	Для каждого Поле Из ОписаниеКлючаЗаписи.МассивПолей Цикл
		Если НЕ ФиксированныйОтбор.Свойство(Поле) Тогда
			Значения = ЗначенияКолонкиТаблицы(ОбновляемыеСтроки, Поле);
			
			Если ИзмеренияОтбора = Неопределено
			 ИЛИ ИзмеренияОтбора.Свойство(Поле) Тогда
				
				МассивИзмеренийОтбора.Добавить(Поле);
				ЗначенияИзмеренийОтбора.Вставить(Поле, Значения);
				
			ИначеЕсли Значения.Количество() = 1 Тогда
				ФиксированныйОтбор.Вставить(Поле, Значения[0]);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	ИмяПервогоИзмерения      = МассивИзмеренийОтбора[0];
	ЗначенияПервогоИзмерения = ЗначенияИзмеренийОтбора[ИмяПервогоИзмерения];
	
	Если МассивИзмеренийОтбора.Количество() > 1 Тогда
		ИмяВторогоИзмерения      = МассивИзмеренийОтбора[1];
		ЗначенияВторогоИзмерения = ЗначенияИзмеренийОтбора[ИмяВторогоИзмерения];
	Иначе
		ИмяВторогоИзмерения      = Неопределено;
		ЗначенияВторогоИзмерения = Неопределено;
	КонецЕсли;
	
	Если МассивИзмеренийОтбора.Количество() > 2 Тогда
		ИмяТретьегоИзмерения      = МассивИзмеренийОтбора[2];
		ЗначенияТретьегоИзмерения = ЗначенияИзмеренийОтбора[ИмяТретьегоИзмерения];
	Иначе
		ИмяТретьегоИзмерения      = Неопределено;
		ЗначенияТретьегоИзмерения = Неопределено;
	КонецЕсли;
	
	ОбновитьНаборыЗаписей(
		МенеджерРегистра,
		ОбновляемыеСтроки,
		ОписаниеКлючаЗаписи.СтрокаПолей,
		ИмяПервогоИзмерения,
		ЗначенияПервогоИзмерения,
		ИмяВторогоИзмерения,
		ЗначенияВторогоИзмерения,
		ИмяТретьегоИзмерения,
		ЗначенияТретьегоИзмерения,
		Истина,
		ФиксированныйОтбор,
		ЕстьИзменения);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Прочие процедуры и функции

// Создает запрос выбора различий между строками регистра в заданной области данных
// (на основе отборов в параметре ПоляИОтбор).
//
// Параметры:
//  ТекстЗапросаВыбораНовых - Строка.
//
//  ПоляИОтбор   - Массив элементов типа Структура("ИмяПоля", ИмяПараметраУсловияОтбора).
//
//  ПолноеИмяРегистра
//               - Строка       - запрос старых формируется автоматически.
//                 Неопределено - запрос старых берется из следующего параметра.
//
//  ТекстЗапросаВыбораСтарых
//               - Строка       - запрос старых, с учетом нестандартных отборов.
//               - Неопределено - когда полное имя регистра определено.
//
// Возвращаемое значение:
//  Строка - текст запрос с учетом оптимизации для СУБД PostgreSQL.
//
Функция ТекстЗапросаВыбораИзменений(ТекстЗапросаВыбораНовых,
                                    ПоляИОтбор,
                                    ПолноеИмяРегистра            = Неопределено,
                                    ТекстЗапросовВременныхТаблиц = Неопределено,
                                    ТекстЗапросаВыбораСтарых     = Неопределено) Экспорт
	
	// Подготовка текста запроса старых данных.
	Если ПолноеИмяРегистра <> Неопределено Тогда
		ТекстЗапросаВыбораСтарых =
		"ВЫБРАТЬ
		|	&ВыбираемыеПоля,
		|	&ПодстановкаПоляВидИзмененияСтроки
		|ИЗ
		|	ПолноеИмяРегистра КАК СтарыеДанные
		|ГДЕ
		|	&УсловияОтбора";
	КонецЕсли;
	
	ВыбираемыеПоля = "";
	УсловияОтбора = "Истина";
	Для каждого ОписаниеПоля Из ПоляИОтбор Цикл
		// Сборка выбираемых полей.
		ВыбираемыеПоля = ВыбираемыеПоля + СтрЗаменить(
			"
			|	СтарыеДанные.Поле,",
			"Поле",
			КлючИЗначение(ОписаниеПоля).Ключ);
			
		// Сборка условий отбора.
		Если ЗначениеЗаполнено(КлючИЗначение(ОписаниеПоля).Значение) Тогда
			УсловияОтбора = УсловияОтбора + СтрЗаменить(
				"
				|	И &ИмяПараметраУсловияОтбора", "&ИмяПараметраУсловияОтбора",
				КлючИЗначение(ОписаниеПоля).Значение);
		КонецЕсли;
	КонецЦикла;
	
	ТекстЗапросаВыбораСтарых =
		СтрЗаменить(ТекстЗапросаВыбораСтарых, "&ВыбираемыеПоля,",  ВыбираемыеПоля);
	
	ТекстЗапросаВыбораСтарых =
		СтрЗаменить(ТекстЗапросаВыбораСтарых, "&УсловияОтбора",    УсловияОтбора);
	
	ТекстЗапросаВыбораСтарых =
		СтрЗаменить(ТекстЗапросаВыбораСтарых, "ПолноеИмяРегистра", ПолноеИмяРегистра);
	
	Если Найти(ТекстЗапросаВыбораНовых, "&ПодстановкаПоляВидИзмененияСтроки") = 0 Тогда
		ВызватьИсключение
			НСтр("ru = 'Ошибка в значении параметра ТекстЗапросаВыбораСтарых
			           |процедуры ТекстЗапросаВыбораИзменений модуля УправлениеДоступомСлужебный.
			           |
			           |В тексте запроса не найдена строка ""&ПодстановкаПоляВидИзмененияСтроки"".'");
	КонецЕсли;
	
	ТекстЗапросаВыбораСтарых = СтрЗаменить(
		ТекстЗапросаВыбораСтарых, "&ПодстановкаПоляВидИзмененияСтроки", "-1 КАК ВидИзмененияСтроки");
	
	Если Найти(ТекстЗапросаВыбораНовых, "&ПодстановкаПоляВидИзмененияСтроки") = 0 Тогда
		ВызватьИсключение
			НСтр("ru = 'Ошибка в значении параметра ТекстЗапросаВыбораНовых
			           |процедуры ТекстЗапросаВыбораИзменений модуля УправлениеДоступомСлужебный.
			           |
			           |В тексте запроса не найдена строка ""&ПодстановкаПоляВидИзмененияСтроки"".'");
	КонецЕсли;
	
	ТекстЗапросаВыбораНовых = СтрЗаменить(
		ТекстЗапросаВыбораНовых,  "&ПодстановкаПоляВидИзмененияСтроки", "1 КАК ВидИзмененияСтроки");
	
	// Подготовка текста запроса выбора изменений.
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	&ВыбираемыеПоля,
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) КАК ВидИзмененияСтроки
	|ИЗ
	|	(ТекстЗапросаВыбораНовых
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ТекстЗапросаВыбораСтарых) КАК ВсеСтроки
	|	
	|СГРУППИРОВАТЬ ПО
	|	&ПоляГруппировки
	|	
	|ИМЕЮЩИЕ
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) <> 0";
	
	ВыбираемыеПоля = "";
	ПоляГруппировки = "";
	Для каждого ОписаниеПоля Из ПоляИОтбор Цикл
		// Сборка выбираемых полей.
		ВыбираемыеПоля = ВыбираемыеПоля + СтрЗаменить(
			"
			|	ВсеСтроки.Поле,",
			"Поле",
			КлючИЗначение(ОписаниеПоля).Ключ);
		
		// Сборка полей соединения.
		ПоляГруппировки = ПоляГруппировки + СтрЗаменить(
			"
			|	ВсеСтроки.Поле,",
			"Поле",
			КлючИЗначение(ОписаниеПоля).Ключ);
	КонецЦикла;
	ПоляГруппировки = Лев(ПоляГруппировки, СтрДлина(ПоляГруппировки)-1);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ВыбираемыеПоля,",  ВыбираемыеПоля);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляГруппировки", ПоляГруппировки);
	
	ТекстЗапроса = СтрЗаменить(
		ТекстЗапроса, "ТекстЗапросаВыбораНовых",  ТекстЗапросаВыбораНовых);
	
	ТекстЗапроса = СтрЗаменить(
		ТекстЗапроса, "ТекстЗапросаВыбораСтарых", ТекстЗапросаВыбораСтарых);
	
	Если ЗначениеЗаполнено(ТекстЗапросовВременныхТаблиц) Тогда
		ТекстЗапроса = ТекстЗапросовВременныхТаблиц +
		"
		|;
		|" + ТекстЗапроса;
	КонецЕсли;
	
	Возврат ТекстЗапроса;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции

Процедура ПриИзмененииНаборовЗначенийДоступа(Знач СсылкаНаОбъект)
	
	СсылкиНаЗависимыеОбъекты = Новый Массив;
	
	УправлениеДоступомПереопределяемый.ПриИзмененииНаборовЗначенийДоступа(
		СсылкаНаОбъект, СсылкиНаЗависимыеОбъекты);
	
	Для каждого СсылкаНаЗависимыйОбъект Из СсылкиНаЗависимыеОбъекты Цикл
		
		Если СсылкаНаЗависимыйОбъект.Метаданные().ТабличныеЧасти.Найти("НаборыЗначенийДоступа") = Неопределено Тогда
			// Изменение объекта не требуется.
			ЗаписатьНаборыЗначенийДоступа(СсылкаНаЗависимыйОбъект);
		Иначе
			// Изменение объекта требуется.
			Объект = СсылкаНаЗависимыйОбъект.ПолучитьОбъект();
			Таблица = ПолучитьНаборыЗначенийДоступаТабличнойЧасти(Объект);
			Если НЕ НаборыЗначенийДоступаТабличнойЧастиИзменены(СсылкаНаЗависимыйОбъект, Таблица) Тогда
				Продолжить;
			КонецЕсли;
			Попытка
				ЗаблокироватьДанныеДляРедактирования(СсылкаНаЗависимыйОбъект, Объект.ВерсияДанных);
				Объект.ОбменДанными.Загрузка = Истина;
				Объект.ДополнительныеСвойства.Вставить("ЗаписатьНаборыЗначенийДоступа");
				Объект.ДополнительныеСвойства.Вставить("ЗаписатьЗависимыеНаборыЗначенийДоступа");
				Объект.ДополнительныеСвойства.Вставить("НаборыЗначенийДоступаТабличнойЧастиЗаполнены");
				Объект.НаборыЗначенийДоступа.Загрузить(Таблица);
				Объект.Записать();
				РазблокироватьДанныеДляРедактирования(СсылкаНаЗависимыйОбъект);
			Исключение
				КраткоеПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'При обновлении зависимого набора значений доступа объекта
					           |""%1"" возникла ошибка:
					           |
					           |%2'"),
					Строка(СсылкаНаЗависимыйОбъект),
					КраткоеПредставлениеОшибки);
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция НаборыЗначенийДоступаРегистраИзменены(СсылкаНаОбъект, НаборЗаписей)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("СсылкаНаОбъект", СсылкаНаОбъект);
	Запрос.УстановитьПараметр("НовыеНаборы",    НаборЗаписей.Выгрузить());
	Запрос.Текст =
	"ВЫБРАТЬ
	|	НовыеНаборы.Объект,
	|	НовыеНаборы.НомерНабора,
	|	НовыеНаборы.ВидДоступа,
	|	НовыеНаборы.ЗначениеДоступа,
	|	НовыеНаборы.Чтение,
	|	НовыеНаборы.Добавление,
	|	НовыеНаборы.Изменение,
	|	НовыеНаборы.Удаление,
	|	НовыеНаборы.ВидДоступаБезГруппЗначенияДоступа,
	|	НовыеНаборы.ВидДоступаЕдинственныйДляТипаЗначенияДоступа,
	|	НовыеНаборы.ВидДоступаЧерезПраваПоЗначениямДоступа,
	|	НовыеНаборы.ВидДоступаПравоЧтения,
	|	НовыеНаборы.ВидДоступаПравоДобавления,
	|	НовыеНаборы.ВидДоступаПравоИзменения,
	|	НовыеНаборы.ТипОбъекта,
	|	НовыеНаборы.ТипЗначенияДоступа
	|ПОМЕСТИТЬ НовыеНаборы
	|ИЗ
	|	&НовыеНаборы КАК НовыеНаборы
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	РегистрСведений.НаборыЗначенийДоступа КАК НаборыЗначенийДоступа
	|		ЛЕВОЕ СОЕДИНЕНИЕ НовыеНаборы КАК НовыеНаборы
	|		ПО НаборыЗначенийДоступа.Объект = НовыеНаборы.Объект
	|			И НаборыЗначенийДоступа.НомерНабора = НовыеНаборы.НомерНабора
	|			И НаборыЗначенийДоступа.ВидДоступа = НовыеНаборы.ВидДоступа
	|			И НаборыЗначенийДоступа.ЗначениеДоступа = НовыеНаборы.ЗначениеДоступа
	|			И НаборыЗначенийДоступа.Чтение = НовыеНаборы.Чтение
	|			И НаборыЗначенийДоступа.Добавление = НовыеНаборы.Добавление
	|			И НаборыЗначенийДоступа.Изменение = НовыеНаборы.Изменение
	|			И НаборыЗначенийДоступа.Удаление = НовыеНаборы.Удаление
	|			И НаборыЗначенийДоступа.ВидДоступаБезГруппЗначенияДоступа = НовыеНаборы.ВидДоступаБезГруппЗначенияДоступа
	|			И НаборыЗначенийДоступа.ВидДоступаЕдинственныйДляТипаЗначенияДоступа = НовыеНаборы.ВидДоступаЕдинственныйДляТипаЗначенияДоступа
	|			И НаборыЗначенийДоступа.ВидДоступаЧерезПраваПоЗначениямДоступа = НовыеНаборы.ВидДоступаЧерезПраваПоЗначениямДоступа
	|			И НаборыЗначенийДоступа.ВидДоступаПравоЧтения = НовыеНаборы.ВидДоступаПравоЧтения
	|			И НаборыЗначенийДоступа.ВидДоступаПравоДобавления = НовыеНаборы.ВидДоступаПравоДобавления
	|			И НаборыЗначенийДоступа.ВидДоступаПравоИзменения = НовыеНаборы.ВидДоступаПравоИзменения
	|			И НаборыЗначенийДоступа.ТипОбъекта = НовыеНаборы.ТипОбъекта
	|			И НаборыЗначенийДоступа.ТипЗначенияДоступа = НовыеНаборы.ТипЗначенияДоступа
	|ГДЕ
	|	НаборыЗначенийДоступа.Объект = &СсылкаНаОбъект
	|	И НовыеНаборы.Объект ЕСТЬ NULL 
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА
	|ИЗ
	|	НовыеНаборы КАК НовыеНаборы
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.НаборыЗначенийДоступа КАК НаборыЗначенийДоступа
	|		ПО (НаборыЗначенийДоступа.Объект = НовыеНаборы.Объект)
	|			И (НаборыЗначенийДоступа.НомерНабора = НовыеНаборы.НомерНабора)
	|			И (НаборыЗначенийДоступа.ВидДоступа = НовыеНаборы.ВидДоступа)
	|			И (НаборыЗначенийДоступа.ЗначениеДоступа = НовыеНаборы.ЗначениеДоступа)
	|			И (НаборыЗначенийДоступа.Чтение = НовыеНаборы.Чтение)
	|			И (НаборыЗначенийДоступа.Добавление = НовыеНаборы.Добавление)
	|			И (НаборыЗначенийДоступа.Изменение = НовыеНаборы.Изменение)
	|			И (НаборыЗначенийДоступа.Удаление = НовыеНаборы.Удаление)
	|			И (НаборыЗначенийДоступа.ВидДоступаБезГруппЗначенияДоступа = НовыеНаборы.ВидДоступаБезГруппЗначенияДоступа)
	|			И (НаборыЗначенийДоступа.ВидДоступаЕдинственныйДляТипаЗначенияДоступа = НовыеНаборы.ВидДоступаЕдинственныйДляТипаЗначенияДоступа)
	|			И (НаборыЗначенийДоступа.ВидДоступаЧерезПраваПоЗначениямДоступа = НовыеНаборы.ВидДоступаЧерезПраваПоЗначениямДоступа)
	|			И (НаборыЗначенийДоступа.ВидДоступаПравоЧтения = НовыеНаборы.ВидДоступаПравоЧтения)
	|			И (НаборыЗначенийДоступа.ВидДоступаПравоДобавления = НовыеНаборы.ВидДоступаПравоДобавления)
	|			И (НаборыЗначенийДоступа.ВидДоступаПравоИзменения = НовыеНаборы.ВидДоступаПравоИзменения)
	|			И (НаборыЗначенийДоступа.ТипОбъекта = НовыеНаборы.ТипОбъекта)
	|			И (НаборыЗначенийДоступа.ТипЗначенияДоступа = НовыеНаборы.ТипЗначенияДоступа)
	|ГДЕ
	|	НаборыЗначенийДоступа.Объект ЕСТЬ NULL ";
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Для процедуры ТекстЗапросаВыбораИзменений.

Функция КлючИЗначение(Структура)
	
	Для каждого КлючИЗначение Из Структура Цикл
		Возврат КлючИЗначение;
	КонецЦикла;
	
КонецФункции

// Для процедур ОбновитьНаборЗаписей и ОбновитьНаборыЗаписей

Функция ГруппаПараметровИзмеренияОбработана(ИмяИзмерения, ЗначенияИзмерения)
	
	Если ИмяИзмерения = Неопределено Тогда
		ЗначенияИзмерения = Неопределено;
		
	ИначеЕсли ЗначенияИзмерения = Неопределено Тогда
		ИмяИзмерения = Неопределено;
		
	ИначеЕсли ТипЗнч(ЗначенияИзмерения) <> Тип("Массив")
	        И ТипЗнч(ЗначенияИзмерения) <> Тип("ФиксированныйМассив") Тогда
		
		ЗначениеИзмерения = ЗначенияИзмерения;
		ЗначенияИзмерения = Новый Массив;
		ЗначенияИзмерения.Добавить(ЗначениеИзмерения);
		
	ИначеЕсли ЗначенияИзмерения.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Процедура УпорядочитьГруппыПараметровИзмерений(ИмяПервогоИзмерения,
                                               ЗначенияПервогоИзмерения,
                                               ИмяВторогоИзмерения,
                                               ЗначенияВторогоИзмерения,
                                               ИмяТретьегоИзмерения,
                                               ЗначенияТретьегоИзмерения)
	
	Если ИмяВторогоИзмерения = Неопределено Тогда
		ИмяВторогоИзмерения       = ИмяТретьегоИзмерения;
		ЗначенияВторогоИзмерения  = ЗначенияТретьегоИзмерения;
		ИмяТретьегоИзмерения      = Неопределено;
		ЗначенияТретьегоИзмерения = Неопределено;
	КонецЕсли;
	
	Если ИмяПервогоИзмерения = Неопределено Тогда
		ИмяПервогоИзмерения       = ИмяВторогоИзмерения;
		ЗначенияПервогоИзмерения  = ЗначенияВторогоИзмерения;
		ИмяВторогоИзмерения       = ИмяТретьегоИзмерения;
		ЗначенияВторогоИзмерения  = ЗначенияТретьегоИзмерения;
		ИмяТретьегоИзмерения      = Неопределено;
		ЗначенияТретьегоИзмерения = Неопределено;
	КонецЕсли;
	
	Если ЗначенияВторогоИзмерения  <> Неопределено
	   И ЗначенияТретьегоИзмерения <> Неопределено
	   И ЗначенияВторогоИзмерения.Количество()
	   > ЗначенияТретьегоИзмерения.Количество() Тогда
		
		ИмяИзмерения      = ИмяВторогоИзмерения;
		ЗначенияИзмерения = ЗначенияВторогоИзмерения;
		
		ИмяВторогоИзмерения       = ИмяТретьегоИзмерения;
		ЗначенияВторогоИзмерения  = ЗначенияТретьегоИзмерения;
		ИмяТретьегоИзмерения      = ИмяИзмерения;
		ЗначенияТретьегоИзмерения = ЗначенияИзмерения;
	КонецЕсли;
	
	Если ЗначенияПервогоИзмерения <> Неопределено
	   И ЗначенияВторогоИзмерения <> Неопределено
	   И ЗначенияПервогоИзмерения.Количество()
	   > ЗначенияВторогоИзмерения.Количество() Тогда
		
		ИмяИзмерения      = ИмяПервогоИзмерения;
		ЗначенияИзмерения = ЗначенияПервогоИзмерения;
		
		ИмяПервогоИзмерения      = ИмяВторогоИзмерения;
		ЗначенияПервогоИзмерения = ЗначенияВторогоИзмерения;
		ИмяВторогоИзмерения      = ИмяИзмерения;
		ЗначенияВторогоИзмерения = ЗначенияИзмерения;
	КонецЕсли;
	
КонецПроцедуры

Функция ПоляНабораЗаписей(НаборЗаписей)
	
	ПоляСравнения = "";
	Таблица = НаборЗаписей.Выгрузить(Новый Массив);
	Для каждого Колонка Из Таблица.Колонки Цикл
		ПоляСравнения = ПоляСравнения + "," + Колонка.Имя;
	КонецЦикла;
	ПоляСравнения = Сред(ПоляСравнения, 2);
	
	Возврат ПоляСравнения;
	
КонецФункции

Функция ОбновитьНовыеЗаписиНабораПоВсемНовымЗаписям(Знач Параметры,
                                                    Знач Отбор,
                                                    Знач СписокПолей,
                                                    Знач ИмяИзмерения,
                                                    Знач ЗначенияИзмерения,
                                                    ЕстьИзменения)
	
	// Открытие транзакции, если её нет или она ещё не открыта
	// для выполнения управляемой блокировки на читаемый набор записей.
	// Может быть ситуации, когда транзакция будет зафиксирована без
	// фактического изменения данных, т.е. если заблокированные данные совпадут.
	Если Параметры.ТранзакцияОткрыта = Ложь Тогда
		Параметры.ТранзакцияОткрыта = Истина;
		НачатьТранзакцию();
	КонецЕсли;
	
	ЗаблокироватьОбластьНабораЗаписей(Параметры.НаборЗаписей, Параметры.ПолноеИмяРегистра);
	
	Параметры.НаборЗаписей.Прочитать();
	НовыеЗаписиНабора = Параметры.НаборЗаписей.Выгрузить();
	НовыеЗаписиНабора.Индексы.Добавить(СписокПолей);
	
	Для каждого Значение Из ЗначенияИзмерения Цикл
		Отбор[ИмяИзмерения] = Значение;
		НайденныеЗаписи = НовыеЗаписиНабора.НайтиСтроки(Отбор);
		Для каждого НайденнаяЗапись Из НовыеЗаписиНабора.НайтиСтроки(Отбор) Цикл
			НовыеЗаписиНабора.Удалить(НайденнаяЗапись);
		КонецЦикла;
		Для каждого НайденнаяЗапись Из Параметры.НовыеЗаписи.НайтиСтроки(Отбор) Цикл
			ЗаполнитьЗначенияСвойств(НовыеЗаписиНабора.Добавить(), НайденнаяЗапись);
		КонецЦикла;
	КонецЦикла;
	
	ОбновитьНаборЗаписей(
		Параметры.НаборЗаписей,
		НовыеЗаписиНабора,
		Параметры.ПоляСравнения,
		,
		,
		ЕстьИзменения,
		,
		Параметры.ТранзакцияОткрыта,
		Истина);
	
КонецФункции

Процедура ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям(Параметры,
                                                           Знач Отбор,
                                                           ЕстьИзменения)
	
	Если Параметры.ТранзакцияОткрыта = Ложь Тогда
		Параметры.ТранзакцияОткрыта = Истина;
		НачатьТранзакцию();
	КонецЕсли;
	
	// Получение количества записей для чтения.
	
	Если Отбор.Количество() = 0 Тогда
		ТекущиеНовыеЗаписи = Параметры.НовыеЗаписи.Скопировать();
		КоличествоДляЧтения = Параметры.КоличествоДляЧтения;
	Иначе
		ТекущиеНовыеЗаписи = Параметры.НовыеЗаписи.Скопировать(Отбор);
		
		ИмяПоля = Параметры.КоличествоПоЗначениям.Колонки[0].Имя;
		СтрокаКоличества = Параметры.КоличествоПоЗначениям.Найти(Отбор[ИмяПоля], ИмяПоля);
		КоличествоДляЧтения = ?(СтрокаКоличества = Неопределено, 0, СтрокаКоличества.Количество);
	КонецЕсли;
	
	ОтборНовойЗаписи = Новый Структура("ВидИзмененияСтроки, " + Параметры.ПоляСравнения, 1);
	ТекущиеНовыеЗаписи.Индексы.Добавить("ВидИзмененияСтроки, " + Параметры.ПоляСравнения);

	КлючиЗаписей = ТекущиеНовыеЗаписи.Скопировать(, "ВидИзмененияСтроки, " + Параметры.ПоляСравнения);
	КлючиЗаписей.Свернуть("ВидИзмененияСтроки, " + Параметры.ПоляСравнения);
	КлючиЗаписей.Свернуть(Параметры.ПоляСравнения, "ВидИзмененияСтроки");
	
	ОтборПоКлючуЗаписи = Новый Структура(Параметры.ПоляСравнения);
	
	Если КоличествоДляЧтения < 1000
	 ИЛИ (  КоличествоДляЧтения < 100000
	      И КлючиЗаписей.Количество() * 50 > КоличествоДляЧтения) Тогда
		// Блочное обновление.
		ЗаблокироватьОбластьНабораЗаписей(Параметры.НаборЗаписей, Параметры.ПолноеИмяРегистра);
		Параметры.НаборЗаписей.Прочитать();
		НовыеЗаписиНабора = Параметры.НаборЗаписей.Выгрузить();
		НовыеЗаписиНабора.Индексы.Добавить(Параметры.ПоляСравнения);
		
		Для каждого Строка Из КлючиЗаписей Цикл
			ЗаполнитьЗначенияСвойств(ОтборПоКлючуЗаписи, Строка);
			НайденныеСтроки = НовыеЗаписиНабора.НайтиСтроки(ОтборПоКлючуЗаписи);
			Если Строка.ВидИзмененияСтроки = -1 Тогда
				Если НайденныеСтроки.Количество() > 0 Тогда
					// Удаление старой строки.
					НовыеЗаписиНабора.Удалить(НайденныеСтроки[0]);
				КонецЕсли;
			Иначе
				// Добавление новой или обновление старой строки.
				Если НайденныеСтроки.Количество() = 0 Тогда
					ЗаполняемаяСтрока = НовыеЗаписиНабора.Добавить();
				Иначе
					ЗаполняемаяСтрока = НайденныеСтроки[0];
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(ОтборНовойЗаписи, ОтборПоКлючуЗаписи);
				НайденныеЗаписи = ТекущиеНовыеЗаписи.НайтиСтроки(ОтборНовойЗаписи);
				Если НайденныеЗаписи.Количество() = 1 Тогда
					НоваяЗапись = НайденныеЗаписи[0];
				Иначе // Ошибка в параметре НовыеЗаписи.
					ИсключениеПриОшибкеПоискаЗаписи(Параметры);
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(ЗаполняемаяСтрока, НоваяЗапись);
			КонецЕсли;
		КонецЦикла;
		// Изменение набора записей, чтобы он отличался от новых записей набора.
		Если Параметры.НаборЗаписей.Количество() = НовыеЗаписиНабора.Количество() Тогда
			Параметры.НаборЗаписей.Добавить();
		КонецЕсли;
		ОбновитьНаборЗаписей(
			Параметры.НаборЗаписей,
			НовыеЗаписиНабора,
			Параметры.ПоляСравнения,
			,
			,
			ЕстьИзменения,
			,
			Параметры.ТранзакцияОткрыта,
			Истина);
	Иначе
		// Построчное обновление.
		Для каждого Строка Из КлючиЗаписей Цикл
			Параметры.НаборДляОднойЗаписи.Очистить();
			ЗаполнитьЗначенияСвойств(ОтборПоКлючуЗаписи, Строка);
			Для каждого КлючИЗначение ИЗ ОтборПоКлючуЗаписи Цикл
				УстановитьОтбор(
					Параметры.НаборДляОднойЗаписи.Отбор[КлючИЗначение.Ключ], КлючИЗначение.Значение);
			КонецЦикла;
			ЗаблокироватьОбластьНабораЗаписей(Параметры.НаборДляОднойЗаписи, Параметры.ПолноеИмяРегистра);
			Если Строка.ВидИзмененияСтроки > -1 Тогда
				// Добавление новой или обновление существующей строки.
				ЗаполнитьЗначенияСвойств(ОтборНовойЗаписи, ОтборПоКлючуЗаписи);
				НайденныеЗаписи = ТекущиеНовыеЗаписи.НайтиСтроки(ОтборНовойЗаписи);
				Если НайденныеЗаписи.Количество() = 1 Тогда
					НоваяЗапись = НайденныеЗаписи[0];
				Иначе // Ошибка в параметре НовыеЗаписи.
					ИсключениеПриОшибкеПоискаЗаписи(Параметры);
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(Параметры.НаборДляОднойЗаписи.Добавить(), НоваяЗапись);
			КонецЕсли;
			Параметры.НаборДляОднойЗаписи.Записать();
			ЕстьИзменения = Истина;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Процедура ИсключениеПриОшибкеПоискаЗаписи(Параметры)
	
	Для каждого СтрокаИзменений Из Параметры.НовыеЗаписи Цикл
		Если СтрокаИзменений.ВидИзмененияСтроки <>  1
		   И СтрокаИзменений.ВидИзмененияСтроки <> -1 Тогда
			
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка в процедуре ОбновитьНаборыЗаписей
				           |общего модуля УправлениеДоступомСлужебный.
				           |
				           |Неверное значение параметра НовыеЗаписи - колонка
				           |ВидИзмененияСтроки содержит недопустимое значение ""%1"".
				           |
				           |Допустимо только 2 значения: ""1"" и ""-1"".'"),
				Строка(СтрокаИзменений.ВидИзмененияСтроки));
		КонецЕсли;
	КонецЦикла;
	
	ВызватьИсключение
		НСтр("ru = 'Ошибка в процедуре ОбновитьНаборыЗаписей
		           |общего модуля УправлениеДоступомСлужебный.
		           |
		           |Не удалось найти требуемую в строку
		           |в значении параметра НовыеЗаписи.'");
	
КонецПроцедуры

Процедура ЗаблокироватьОбластьНабораЗаписей(НаборЗаписей, ПолноеИмяРегистра = Неопределено)
	
	Если НЕ ТранзакцияАктивна() Тогда
		Возврат;
	КонецЕсли;
	
	Если ПолноеИмяРегистра = Неопределено Тогда
		ПолноеИмяРегистра = Метаданные.НайтиПоТипу(ТипЗнч(НаборЗаписей)).ПолноеИмя();
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить(ПолноеИмяРегистра);
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
	Для каждого ЭлементОтбора Из НаборЗаписей.Отбор Цикл
		Если ЭлементОтбора.Использование Тогда
			ЭлементБлокировки.УстановитьЗначение(ЭлементОтбора.ПутьКДанным, ЭлементОтбора.Значение);
		КонецЕсли;
	КонецЦикла;
	Блокировка.Заблокировать();
	
КонецПроцедуры

Процедура УстановитьОтбор(ЭлементОтбора, ЗначениеОтбора)
	
	ЭлементОтбора.Значение = ЗначениеОтбора;
	ЭлементОтбора.Использование = Истина;
	
КонецПроцедуры

Функция ЗаписьНесколькимиНаборами(Параметры, Отбор, ИмяПоля, ЗначенияПоля)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ЗначенияПоля", ЗначенияПоля);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	&ТекущаяТаблица КАК ТекущаяТаблица
	|ГДЕ
	|	&УсловиеОтбора
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	&ТекущаяТаблица КАК ТекущаяТаблица
	|ГДЕ
	|	ТекущаяТаблица.ИмяПоля В(&ЗначенияПоля)
	|	И &УсловиеОтбора
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТекущаяТаблица.ИмяПоля КАК ИмяПоля,
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	&ТекущаяТаблица КАК ТекущаяТаблица
	|ГДЕ
	|	ТекущаяТаблица.ИмяПоля В(&ЗначенияПоля)
	|	И &УсловиеОтбора
	|
	|СГРУППИРОВАТЬ ПО
	|	ТекущаяТаблица.ИмяПоля";
	
	УсловиеОтбора = "Истина";
	Если Параметры.ФиксированныйОтбор <> Неопределено Тогда
		Для каждого КлючИЗначение Из Параметры.ФиксированныйОтбор Цикл
			УсловиеОтбора = УсловиеОтбора + "
			|	И ТекущаяТаблица." + КлючИЗначение.Ключ + " = &" + КлючИЗначение.Ключ;
			Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
	ОтборДобавляемых = Новый Структура;
	ОтборДобавляемых.Вставить("ВидИзмененияСтроки", 1);
	ОтборУдаляемых = Новый Структура;
	ОтборУдаляемых.Вставить("ВидИзмененияСтроки", -1);
	
	Для каждого КлючИЗначение Из Отбор Цикл
		УсловиеОтбора = УсловиеОтбора + "
		|	И ТекущаяТаблица." + КлючИЗначение.Ключ + " = &" + КлючИЗначение.Ключ;
		Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		ОтборДобавляемых.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		ОтборУдаляемых.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИмяПоля", ИмяПоля);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ТекущаяТаблица", Параметры.ПолноеИмяРегистра);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеОтбора", УсловиеОтбора);
	
	РезультатыЗапросов = Запрос.ВыполнитьПакет();
	
	// Количество всех без отбора.
	КоличествоВсех = РезультатыЗапросов[0].Выгрузить()[0].Количество;
	Параметры.Вставить("КоличествоДляЧтения", КоличествоВсех);
	
	// Количество обновляемых с отбором.
	КоличествоОбновляемых = РезультатыЗапросов[1].Выгрузить()[0].Количество;
	
	КоличествоДобавляемых = Параметры.НовыеЗаписи.НайтиСтроки(ОтборДобавляемых).Количество();
	Если КоличествоДобавляемых > КоличествоОбновляемых Тогда
		КоличествоОбновляемых = КоличествоДобавляемых;
	КонецЕсли;
	
	КоличествоУдаляемых = Параметры.НовыеЗаписи.НайтиСтроки(ОтборУдаляемых).Количество();
	Если КоличествоУдаляемых > КоличествоОбновляемых Тогда
		КоличествоОбновляемых = КоличествоУдаляемых;
	КонецЕсли;
	
	// Количество для чтения по значениям отбора.
	КоличествоПоЗначениям = РезультатыЗапросов[2].Выгрузить();
	КоличествоПоЗначениям.Индексы.Добавить(ИмяПоля);
	Параметры.Вставить("КоличествоПоЗначениям", КоличествоПоЗначениям);
	
	Возврат КоличествоВсех * 0.7 > КоличествоОбновляемых;
	
КонецФункции

Процедура ПрочитатьКоличествоДляЧтения(Параметры)
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	&ТекущаяТаблица КАК ТекущаяТаблица
	|ГДЕ
	|	&УсловиеОтбора";
	
	УсловиеОтбора = "Истина";
	Если Параметры.ФиксированныйОтбор <> Неопределено Тогда
		Для каждого КлючИЗначение Из Параметры.ФиксированныйОтбор Цикл
			УсловиеОтбора = УсловиеОтбора + "
			|	И ТекущаяТаблица." + КлючИЗначение.Ключ + " = &" + КлючИЗначение.Ключ;
			Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ТекущаяТаблица", Параметры.ПолноеИмяРегистра);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеОтбора", УсловиеОтбора);
	
	РезультатыЗапросов = Запрос.ВыполнитьПакет();
	
	Параметры.Вставить("КоличествоДляЧтения", Запрос.Выполнить().Выгрузить()[0].Количество);
	
КонецПроцедуры

// Для процедуры ОбновитьРегистрСведений

Функция ЗначенияКолонкиТаблицы(Таблица, ИмяКолонки)
	
	НоваяТаблица = Таблица.Скопировать(, ИмяКолонки);
	
	НоваяТаблица.Свернуть(ИмяКолонки);
	
	Возврат НоваяТаблица.ВыгрузитьКолонку(ИмяКолонки);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обновление информационной базы

// Обновляет вспомогательные данные, которые зависят только
// от конфигурации.
// Записывает изменения этих данных по версиям конфигурации
// (если изменения есть), чтобы использовать эти изменения
// при обновлении остальных вспомогательных данных, например,
// в обработчике ОбновитьВспомогательныеДанныеПриОбновленииИБ.
//
Процедура ОбновитьПараметрыОграниченияДоступа() Экспорт
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("Константа.ПараметрыОграниченияДоступа");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ПраваРолей");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ЗависимостиПравДоступа");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		
		Константы.ПараметрыОграниченияДоступа.СоздатьМенеджерЗначения().ОбновитьОбщиеПараметры();
		РегистрыСведений.ПраваРолей.ОбновитьДанныеРегистра();
		РегистрыСведений.ЗависимостиПравДоступа.ОбновитьДанныеРегистра();
		ПланыВидовХарактеристик.ВидыДоступа.ОбновитьОписаниеСвойств();
		Справочники.ПрофилиГруппДоступа.ОбновитьОписаниеПоставляемыхПрофилей();
		Справочники.ПрофилиГруппДоступа.ОбновитьСоставПредопределенныхПрофилей();
		РегистрыСведений.ПраваПоЗначениямДоступа.ОбновитьВозможныеПраваПоЗначенияДоступа();
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Очищает вспомогательные данные, которые зависят только
// от конфигурации.
// Используется как обработчик очистки вспомогательных данных,
// которые зависят только от конфигурации, чтобы вызвать проверку и
// обновление остальных вспомогательных данных при обновлении ИБ,
// например, в обработчике ОбновитьВспомогательныеДанныеПриОбновленииИБ.
//
Процедура ОчиститьПараметрыОграниченияДоступа() Экспорт
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("Константа.ПараметрыОграниченияДоступа");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ПраваРолей");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ЗависимостиПравДоступа");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		
		// Очистка прав ролей.
		НаборЗаписей = РегистрыСведений.ПраваРолей.СоздатьНаборЗаписей();
		НаборЗаписей.Записать();
		
		// Очистка зависимостей прав.
		НаборЗаписей = РегистрыСведений.ЗависимостиПравДоступа.СоздатьНаборЗаписей();
		НаборЗаписей.Записать();
		
		// Очистка остальных данных построенных по метаданным и их изменений.
		Константы.ПараметрыОграниченияДоступа.Установить(Новый ХранилищеЗначения(Неопределено));
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Обновляет вспомогательные данные, которые зависят от конфигурации частично.
//
// Обновляется при наличии изменений конфигурации, записанных в параметры
// ограничения доступа при обновлении базы данных на текущую версию конфигурации.
//
Процедура ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации() Экспорт
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ТаблицыГруппДоступа");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ПраваПоЗначениямДоступа");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки = Блокировка.Добавить("Справочник.ПрофилиГруппДоступа");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки = Блокировка.Добавить("Справочник.ГруппыДоступа");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		
		РегистрыСведений.ТаблицыГруппДоступа.ОбновитьДанныеРегистраПоИзменениямКонфигурации();
		РегистрыСведений.ПраваПоЗначениямДоступа.ОбновитьВспомогательныеДанныеРегистраПоИзменениямКонфигурации();
		Справочники.ПрофилиГруппДоступа.ОбновитьПоставляемыеПрофилиПоИзменениямКонфигурации();
		Справочники.ГруппыДоступа.ПометитьНаУдалениеГруппыДоступаПомеченныхПрофилей();
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Преобразует реквизит УдалитьРоль в реквизит Роль в табличной части Роли
// справочника Профили групп доступа.
//
Процедура ПреобразоватьИменаРолейВИдентификаторы() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Роли.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ПрофилиГруппДоступа.Роли КАК Роли
	|ГДЕ
	|	НЕ(Роли.Роль <> ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
	|				И Роли.УдалитьРоль = """")";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		Индекс = Объект.Роли.Количество()-1;
		Пока Индекс >= 0 Цикл
			Строка = Объект.Роли[Индекс];
			Если ЗначениеЗаполнено(Строка.Роль) Тогда
				Строка.УдалитьРоль = "";
			ИначеЕсли ЗначениеЗаполнено(Строка.УдалитьРоль) Тогда
				ЕстьИзменения = Истина;
				МетаданныеРоли = Метаданные.Роли.Найти(Строка.УдалитьРоль);
				Если МетаданныеРоли <> Неопределено Тогда
					Строка.УдалитьРоль = "";
					Строка.Роль = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(
						МетаданныеРоли);
				Иначе
					Объект.Роли.Удалить(Индекс);
				КонецЕсли;
			Иначе
				Объект.Роли.Удалить(Индекс);
			КонецЕсли;
			Индекс = Индекс-1;
		КонецЦикла;
		Объект.ОбменДанными.Загрузка = Истина;
		Объект.Записать();
	КонецЦикла;
	
КонецПроцедуры
